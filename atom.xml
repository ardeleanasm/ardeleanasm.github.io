<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>ardeleanasm</title>
    <link href="http://ardeleanasm.github.io/atom.xml" rel="self" />
    <link href="http://ardeleanasm.github.io" />
    <id>http://ardeleanasm.github.io/atom.xml</id>
    <author>
        <name>ardeleanasm</name>
        <email>ardeleanasm@gmail.com</email>
    </author>
    <updated>2018-04-08T00:00:00Z</updated>
    <entry>
    <title>Common-Cathode 7-segments display driver implementation in Verilog</title>
    <link href="http://ardeleanasm.github.io/posts/2018-04-08-Common-Cathode-7-segments-display-driver-implementation-in-Verilog.html" />
    <id>http://ardeleanasm.github.io/posts/2018-04-08-Common-Cathode-7-segments-display-driver-implementation-in-Verilog.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[Common-Cathode 7-segments display driver implementation in Verilog]]></summary>
</entry>
<entry>
    <title>2018-04-08-Common-Cathode-7-segments-display-driver-implementation-in-Verilog</title>
    <link href="http://ardeleanasm.github.io/posts/2018-04-08-Common-Cathode-7-segments-display-driver-implementation-in-Verilog.html" />
    <id>http://ardeleanasm.github.io/posts/2018-04-08-Common-Cathode-7-segments-display-driver-implementation-in-Verilog.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!--<article>
    <section class="header">
        Posted on April  8, 2018
        
    </section>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="common-cathode-7-segments-display-driver-implementation-in-verilog">Common-Cathode 7-segments display driver implementation in Verilog</h1>
<div class="section header">
Posted on April 8, 2018
</div>
<div class="info">
Tags: <a href="../tags/verilog.html">verilog</a>, <a href="../tags/7-segments%20driver.html">7-segments driver</a>
</div>
<div class="section">
<h3 id="description">Description</h3>
<p>7-segment LED type displays provide a convenient way to display data, like numbers, letters, and typically consist of seven individual LEDs within one single display package. In order to produce the required data ( HEX characters from 0 to 9 and A to F), on the display the correct combination of LED segments need to be illuminated. However, to display BCD information on 7-segments we need to use a BCD to 7 segments decoder like 74LS47 or HC4511.</p>
<p>A 7-segment LED display usually have 8 connections for each LED segment and one that acts as a GND or VCC. There are some displays that have an additional input pin used to display a decimal point. Anyway, in electronics there are 2 types of 7-segment displays:</p>
<ol style="list-style-type: decimal">
<li><strong>Common Cathode Display</strong> - all the cathode connections of the LED segments are joined together to <strong>Gnd</strong>. This means that a segment is illuminated by applying a logic ‘1’ signal to the <em>Anode</em> terminal. (Img 1a)</li>
<li><strong>Common Anode Display</strong> - all the anode connections of the LED segments are joined together to <strong>Vcc</strong> which means that to illuminate a segment a logic ‘0’ needs to be applied to the <em>Cathode</em> terminal. (Img 1b)</li>
</ol>
<p>{% include img.html img=“resources/common_cathode_anode_leds.png” title=“Img 1:LED display types” caption=“Img 1:LED display types” %}</p>
<p>{% include img.html img=“resources/led_scheme.png” title=“Img 2:7-segment display format” caption=“Img 2: 7-segment display format” %}</p>
<p>Considering Img 2 we can create the truth table below. Because we use a common cathode 7 segment display we will have 1 for each illuminated segment and 0 for not illuminated. Since we will design a BCD to 7-segments the values from 10 to 15 are invalid. For there values we will mark the corresponding segment with X, meaning don’t care.</p>
<table>
<thead>
<tr class="header">
<th><span class="math display">\[X_{3}\]</span></th>
<th><span class="math display">\[X_{2}\]</span></th>
<th><span class="math display">\[X_{1}\]</span></th>
<th><span class="math display">\[X_{0}\]</span></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>Display</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>7</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>8</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>9</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Based on the above table we can express output as minterm expansions:</p>
<p><span class="math display">\[a = F_{1} (A, B, C, D) = \sum m(0, 2, 3, 5, 7, 8, 9)\]</span></p>
<p><span class="math display">\[b = F_{2} (A, B, C, D) = \sum m(0, 1, 2, 3, 4, 7, 8, 9)\]</span></p>
<p><span class="math display">\[c = F_{3} (A, B, C, D) = \sum m(0, 1, 3, 4, 5, 6, 7, 8, 9)\]</span></p>
<p><span class="math display">\[d = F_{4} (A, B, C, D) = \sum m(0, 2, 3, 5, 6, 8)\]</span></p>
<p><span class="math display">\[e = F_{5} (A, B, C, D) = \sum m(0, 2, 6, 8)\]</span></p>
<p><span class="math display">\[f = F_{6} (A, B, C, D) = \sum m(0, 4, 5, 6, 8, 9)\]</span></p>
<p><span class="math display">\[g = F_{7} (A, B, C, D) = \sum m(2, 3, 4, 5, 6, 8, 9)\]</span></p>
<p>Now we can construct the Karnaugh’s Map for each output term and then simplify it to obtain a logic combination of inputs for each output.</p>
<p><span class="math display">\[a=A\overline{B}\overline{C}+\overline{A}(C+\overline{B}\overline{D}+BD)\]</span></p>
<p><span class="math display">\[b=\overline{AC}\overline{B}+\overline{A}(CD+\overline{C}\overline{D})\]</span></p>
<p><span class="math display">\[c=\overline{B}\overline{C}+\overline{A}(B+D)\]</span></p>
<p><span class="math display">\[d=\overline{A}\overline{B}(C+\overline{D})+\overline{A}(C\overline{D}+BD\overline{C})+A\overline{B}\overline{C}\]</span></p>
<p><span class="math display">\[e=\overline{D}(\overline{B}\overline{C}+\overline{A}C)\]</span></p>
<p><span class="math display">\[f=\overline{A}(B\overline{CD}+\overline{C}\overline{D})+A\overline{B}\overline{C}\]</span></p>
<p><span class="math display">\[g=\overline{A}(C\overline{BD}+B\overline{C})+A\overline{B}\overline{C}\]</span></p>
<h3 id="implementation">Implementation</h3>
<p>{% include img.html img=“resources/hc4511_block_scheme.png” title=“Img 3:TI HC4511 block scheme” caption=“Img 3: TI HC4511 block scheme” %}</p>
<p>In Img 3 is the block scheme of the TI HC4511 BCD-to-7 segment latch/decoder/driver.</p>
<h4 id="decoder-implementation">Decoder Implementation</h4>
<p>The <strong>decoder</strong> will have 2 input ports ( <em>BL</em> signal, <em>D[0:3]</em>) and one output port, <em>D[0:7]</em>and will contain the implementation of the above equations. Moreover, the output of decoder will be blank ( 0 ) if <strong>BL</strong> signal is 0.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> dec_7seg(
    datain,bl,dataout
    );

    <span class="dt">input</span>   [<span class="dv">3</span>:<span class="dv">0</span>]   datain; 
    <span class="dt">input</span>           bl;
    <span class="dt">output</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   dataout;
    
    <span class="kw">assign</span> dataout[<span class="dv">7</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:(datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|
                ((~datain[<span class="dv">3</span>])&amp;(datain[<span class="dv">1</span>]|(((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">0</span>]))|(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>]))));

    <span class="kw">assign</span> dataout[<span class="dv">6</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:((~(datain[<span class="dv">3</span>]&amp;datain[<span class="dv">1</span>]))&amp;(~datain[<span class="dv">2</span>]))|
                        ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;datain[<span class="dv">0</span>])|((~datain[<span class="dv">1</span>])&amp;(~datain[<span class="dv">0</span>]))));

    <span class="kw">assign</span> dataout[<span class="dv">5</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|
                        ((~datain[<span class="dv">3</span>])&amp;(datain[<span class="dv">2</span>]|datain[<span class="dv">0</span>]));

	<span class="kw">assign</span> dataout[<span class="dv">4</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
                ((~datain[<span class="dv">3</span>])&amp;(~datain[<span class="dv">2</span>])&amp;(datain[<span class="dv">1</span>]|(~datain[<span class="dv">0</span>])))|
                ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;(~datain[<span class="dv">0</span>]))|(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>]&amp;(~datain[<span class="dv">1</span>]))))|
                (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">3</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
                (~datain[<span class="dv">0</span>])&amp;(((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|((~datain[<span class="dv">3</span>])&amp;datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">2</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
        ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">2</span>]&amp;(~(datain[<span class="dv">1</span>]&amp;datain[<span class="dv">0</span>])))|((~datain[<span class="dv">1</span>])&amp;(~datain[<span class="dv">0</span>]))))|
        (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">1</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
            ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;(~(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>])))|(datain[<span class="dv">2</span>]&amp;(~datain[<span class="dv">1</span>]))))|
            (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">0</span>]=<span class="bn">1&#39;b0</span>;<span class="co">//dot</span>
<span class="kw">endmodule</span> <span class="co">// decoder</span></code></pre></div>
</div>
<h4 id="latch-implementation">Latch Implementation</h4>
<p>We can easily implement a D-type latch using an <strong>always</strong> block. We will need 5 ports, 3 for input signals ( data in, enable, <span class="math inline">\(\overline{enable}\)</span> ) and 2 for output signals ( q and <span class="math inline">\(\overline{q}\)</span>).</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> dlatch(
    d,q,nq,ena,nena
    );
    
    <span class="dt">input</span>       d;
    <span class="dt">input</span>       ena;
    <span class="dt">input</span>       nena;
    <span class="dt">output</span>  <span class="dt">reg</span> q;
    <span class="dt">output</span>  <span class="dt">reg</span> nq;

    <span class="kw">always</span> @(d,ena,nena) <span class="kw">begin:</span><span class="dt"> d</span>_latch_procedure
        <span class="kw">if</span>(ena) <span class="kw">begin</span>
            q&lt;=d;
            nq&lt;=~d;
        <span class="kw">end</span> <span class="co">// if( le=&#39;1&#39;)</span>
        <span class="kw">else</span> <span class="kw">begin</span>
        <span class="kw">end</span>

    <span class="kw">end</span> <span class="co">// d_latch_procedure</span>

<span class="kw">endmodule</span> <span class="co">// dlatch</span></code></pre></div>
</div>
<h4 id="driver-implementation">Driver Implementation</h4>
<p>The driver will have to set output to 1 if <em>LT</em> (Lamp Test) signal is low, otherwise the output will be transparent to input. In other words, in can be implemented as a latch.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> drv_7seg(
    lt,inbus,outbus
    );

    <span class="dt">input</span>               lt;
    <span class="dt">input</span>       [<span class="dv">7</span>:<span class="dv">0</span>]   inbus;
    <span class="dt">output</span>  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;

    <span class="kw">always</span> @(lt,inbus) <span class="kw">begin :</span><span class="dt"> d</span>rv_7seg
        <span class="kw">if</span>(lt) <span class="kw">begin</span>
            outbus&lt;=inbus;
        <span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span>
            outbus&lt;=<span class="bn">8&#39;b11111111</span>; 
        <span class="kw">end</span>
    <span class="kw">end</span>

<span class="kw">endmodule</span> <span class="co">// drv_7seg</span></code></pre></div>
</div>
<h4 id="modules-instantiation-and-testbench">Modules Instantiation and testbench</h4>
<p>Now that we have all the modules defined we can create a new module <strong>driver_7_segments</strong> and instantiate them.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> driver_7_segments(
    inbus,le,lt,bl,outbus,
    );
    
    <span class="dt">input</span>       [<span class="dv">3</span>:<span class="dv">0</span>]   inbus;      <span class="co">//input data</span>
    <span class="dt">input</span>               le;             <span class="co">//latch-enable</span>
    <span class="dt">input</span>               lt;             <span class="co">//lamp-test-&gt;displays 8</span>
    <span class="dt">input</span>               bl;             <span class="co">//blanking-&gt; blank</span>
    <span class="dt">output</span> <span class="dt">reg</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;


    <span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>]  latch_output;
    <span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>]  decoder_output;

    dlatch latch0(.d  (inbus[<span class="dv">0</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">0</span>]),.nq ());
    
    dlatch latch1(.d  (inbus[<span class="dv">1</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">1</span>]),.nq ());
    
    dlatch latch2(.d  (inbus[<span class="dv">2</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">2</span>]),.nq ());

    dlatch latch3(.d  (inbus[<span class="dv">3</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">3</span>]),.nq ());
    
    dec_7seg decoder_7_segments(.datain (latch_output),.bl     (bl),.dataout(decoder_output));
    
    drv_7seg driver_7_segments(.inbus (decoder_output),.lt    (lt),.outbus(outbus));
   
<span class="kw">endmodule</span> <span class="co">// segments_driver</span></code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`include </span><span class="fl">&quot;testbench/test_inc.v&quot;</span>
<span class="kw">module</span> driver_7_segments_tb;

	<span class="dt">reg</span>       [<span class="dv">3</span>:<span class="dv">0</span>]   inbus;      <span class="co">//input data</span>
    <span class="dt">reg</span>               le;             <span class="co">//latch-enable</span>
    <span class="dt">reg</span>               lt;             <span class="co">//lamp-test-&gt;displays 8</span>
    <span class="dt">reg</span>               bl;             <span class="co">//blanking-&gt; blank</span>
    <span class="dt">wire</span> <span class="dt">reg</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;

    driver_7_segments driver(.inbus (inbus),.le (le),.lt (lt),.bl (bl),.outbus(outbus));

    <span class="kw">initial</span> <span class="kw">begin</span>
        <span class="dt">$dumpfile</span>(<span class="st">&quot;segments_driver_tb.vcd&quot;</span>);
        <span class="dt">$dumpvars</span>;

        <span class="co">//Lamp Test</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//blanking is disabled</span>
        inbus&lt;=<span class="bn">4&#39;b0000</span>;<span class="co">//0 on inbus</span>
        lt&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//lamp test enabled</span>
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111111</span>);

        <span class="bn">#50</span> 
        <span class="co">//Blanking Test</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//blanking is enabled</span>
		inbus&lt;=<span class="bn">4&#39;b0000</span>;<span class="co">//0 on inbus</span>
        lt&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//lamp test disabled</span>
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b00000000</span>);        

        <span class="bn">#50</span>
        <span class="co">//test all values</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//blanking is disabled</span>
        lt&lt;=<span class="bn">1&#39;b1</span>; <span class="co">//lamp test is disabled</span>
        
        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0000</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111100</span>);
		
		<span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0001</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b01100000</span>);

		<span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0010</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11011010</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0011</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11110010</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0100</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b01100110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0101</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b10110110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0110</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b10111110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0111</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11100000</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b1000</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b1001</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11110110</span>);
    <span class="kw">end</span> <span class="co">// initial</span>

    <span class="kw">initial</span> <span class="kw">begin :</span><span class="dt">d</span>ump_proc
            <span class="dt">$display</span>(<span class="st">&quot;</span><span class="ch">\t\t</span><span class="st">Time</span><span class="ch">\t</span><span class="st">INBUS</span><span class="ch">\t</span><span class="st">/LE</span><span class="ch">\t</span><span class="st">/LT</span><span class="ch">\t</span><span class="st">/BL</span><span class="ch">\t</span><span class="st">OUTBUS&quot;</span>);
            <span class="dt">$monitor</span>(<span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b&quot;</span>,<span class="dt">$time</span>,inbus,le,lt,bl,outbus);
    <span class="kw">end</span> <span class="co">// dump_proc</span>
<span class="kw">endmodule</span> <span class="co">// segments_driver_tb</span></code></pre></div>
</div>
<hr />
<h3 id="bibliography">Bibliography</h3>
<ol style="list-style-type: decimal">
<li><a href="http://www.ti.com/lit/ds/symlink/cd74hc4511.pdf">TI HC4511 Datasheet</a></li>
<li><a href="https://www.electronicshub.org/bcd-7-segment-led-display-decoder-circuit/">Electronics Hub</a></li>
<li><a href="https://www.electronics-tutorials.ws/combination/comb_6.html">Electronics Tutorials</a></li>
</ol>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on April  8, 2018
        
    </section>
    <div class="info">
        
        Tags: 
        
    </div>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="common-cathode-7-segments-display-driver-implementation-in-verilog">Common-Cathode 7-segments display driver implementation in Verilog</h1>
<div class="section header">
Posted on April 8, 2018
</div>
<div class="info">
Tags: <a href="../tags/verilog.html">verilog</a>, <a href="../tags/7-segments%20driver.html">7-segments driver</a>
</div>
<div class="section">
<h3 id="description">Description</h3>
<p>7-segment LED type displays provide a convenient way to display data, like numbers, letters, and typically consist of seven individual LEDs within one single display package. In order to produce the required data ( HEX characters from 0 to 9 and A to F), on the display the correct combination of LED segments need to be illuminated. However, to display BCD information on 7-segments we need to use a BCD to 7 segments decoder like 74LS47 or HC4511.</p>
<p>A 7-segment LED display usually have 8 connections for each LED segment and one that acts as a GND or VCC. There are some displays that have an additional input pin used to display a decimal point. Anyway, in electronics there are 2 types of 7-segment displays:</p>
<ol style="list-style-type: decimal">
<li><strong>Common Cathode Display</strong> - all the cathode connections of the LED segments are joined together to <strong>Gnd</strong>. This means that a segment is illuminated by applying a logic ‘1’ signal to the <em>Anode</em> terminal. (Img 1a)</li>
<li><strong>Common Anode Display</strong> - all the anode connections of the LED segments are joined together to <strong>Vcc</strong> which means that to illuminate a segment a logic ‘0’ needs to be applied to the <em>Cathode</em> terminal. (Img 1b)</li>
</ol>
<p>{% include img.html img=“resources/common_cathode_anode_leds.png” title=“Img 1:LED display types” caption=“Img 1:LED display types” %}</p>
<p>{% include img.html img=“resources/led_scheme.png” title=“Img 2:7-segment display format” caption=“Img 2: 7-segment display format” %}</p>
<p>Considering Img 2 we can create the truth table below. Because we use a common cathode 7 segment display we will have 1 for each illuminated segment and 0 for not illuminated. Since we will design a BCD to 7-segments the values from 10 to 15 are invalid. For there values we will mark the corresponding segment with X, meaning don’t care.</p>
<table>
<thead>
<tr class="header">
<th><span class="math display">\[X_{3}\]</span></th>
<th><span class="math display">\[X_{2}\]</span></th>
<th><span class="math display">\[X_{1}\]</span></th>
<th><span class="math display">\[X_{0}\]</span></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
<th>Display</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>3</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>5</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>6</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>7</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>8</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>9</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Based on the above table we can express output as minterm expansions:</p>
<p><span class="math display">\[a = F_{1} (A, B, C, D) = \sum m(0, 2, 3, 5, 7, 8, 9)\]</span></p>
<p><span class="math display">\[b = F_{2} (A, B, C, D) = \sum m(0, 1, 2, 3, 4, 7, 8, 9)\]</span></p>
<p><span class="math display">\[c = F_{3} (A, B, C, D) = \sum m(0, 1, 3, 4, 5, 6, 7, 8, 9)\]</span></p>
<p><span class="math display">\[d = F_{4} (A, B, C, D) = \sum m(0, 2, 3, 5, 6, 8)\]</span></p>
<p><span class="math display">\[e = F_{5} (A, B, C, D) = \sum m(0, 2, 6, 8)\]</span></p>
<p><span class="math display">\[f = F_{6} (A, B, C, D) = \sum m(0, 4, 5, 6, 8, 9)\]</span></p>
<p><span class="math display">\[g = F_{7} (A, B, C, D) = \sum m(2, 3, 4, 5, 6, 8, 9)\]</span></p>
<p>Now we can construct the Karnaugh’s Map for each output term and then simplify it to obtain a logic combination of inputs for each output.</p>
<p><span class="math display">\[a=A\overline{B}\overline{C}+\overline{A}(C+\overline{B}\overline{D}+BD)\]</span></p>
<p><span class="math display">\[b=\overline{AC}\overline{B}+\overline{A}(CD+\overline{C}\overline{D})\]</span></p>
<p><span class="math display">\[c=\overline{B}\overline{C}+\overline{A}(B+D)\]</span></p>
<p><span class="math display">\[d=\overline{A}\overline{B}(C+\overline{D})+\overline{A}(C\overline{D}+BD\overline{C})+A\overline{B}\overline{C}\]</span></p>
<p><span class="math display">\[e=\overline{D}(\overline{B}\overline{C}+\overline{A}C)\]</span></p>
<p><span class="math display">\[f=\overline{A}(B\overline{CD}+\overline{C}\overline{D})+A\overline{B}\overline{C}\]</span></p>
<p><span class="math display">\[g=\overline{A}(C\overline{BD}+B\overline{C})+A\overline{B}\overline{C}\]</span></p>
<h3 id="implementation">Implementation</h3>
<p>{% include img.html img=“resources/hc4511_block_scheme.png” title=“Img 3:TI HC4511 block scheme” caption=“Img 3: TI HC4511 block scheme” %}</p>
<p>In Img 3 is the block scheme of the TI HC4511 BCD-to-7 segment latch/decoder/driver.</p>
<h4 id="decoder-implementation">Decoder Implementation</h4>
<p>The <strong>decoder</strong> will have 2 input ports ( <em>BL</em> signal, <em>D[0:3]</em>) and one output port, <em>D[0:7]</em>and will contain the implementation of the above equations. Moreover, the output of decoder will be blank ( 0 ) if <strong>BL</strong> signal is 0.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> dec_7seg(
    datain,bl,dataout
    );

    <span class="dt">input</span>   [<span class="dv">3</span>:<span class="dv">0</span>]   datain; 
    <span class="dt">input</span>           bl;
    <span class="dt">output</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   dataout;
    
    <span class="kw">assign</span> dataout[<span class="dv">7</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:(datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|
                ((~datain[<span class="dv">3</span>])&amp;(datain[<span class="dv">1</span>]|(((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">0</span>]))|(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>]))));

    <span class="kw">assign</span> dataout[<span class="dv">6</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:((~(datain[<span class="dv">3</span>]&amp;datain[<span class="dv">1</span>]))&amp;(~datain[<span class="dv">2</span>]))|
                        ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;datain[<span class="dv">0</span>])|((~datain[<span class="dv">1</span>])&amp;(~datain[<span class="dv">0</span>]))));

    <span class="kw">assign</span> dataout[<span class="dv">5</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|
                        ((~datain[<span class="dv">3</span>])&amp;(datain[<span class="dv">2</span>]|datain[<span class="dv">0</span>]));

	<span class="kw">assign</span> dataout[<span class="dv">4</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
                ((~datain[<span class="dv">3</span>])&amp;(~datain[<span class="dv">2</span>])&amp;(datain[<span class="dv">1</span>]|(~datain[<span class="dv">0</span>])))|
                ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;(~datain[<span class="dv">0</span>]))|(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>]&amp;(~datain[<span class="dv">1</span>]))))|
                (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">3</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
                (~datain[<span class="dv">0</span>])&amp;(((~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]))|((~datain[<span class="dv">3</span>])&amp;datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">2</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
        ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">2</span>]&amp;(~(datain[<span class="dv">1</span>]&amp;datain[<span class="dv">0</span>])))|((~datain[<span class="dv">1</span>])&amp;(~datain[<span class="dv">0</span>]))))|
        (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">1</span>]=(bl==<span class="bn">1&#39;b0</span>)?<span class="bn">8&#39;b00000000</span>:
            ((~datain[<span class="dv">3</span>])&amp;((datain[<span class="dv">1</span>]&amp;(~(datain[<span class="dv">2</span>]&amp;datain[<span class="dv">0</span>])))|(datain[<span class="dv">2</span>]&amp;(~datain[<span class="dv">1</span>]))))|
            (datain[<span class="dv">3</span>]&amp;(~datain[<span class="dv">2</span>])&amp;(~datain[<span class="dv">1</span>]));

    <span class="kw">assign</span> dataout[<span class="dv">0</span>]=<span class="bn">1&#39;b0</span>;<span class="co">//dot</span>
<span class="kw">endmodule</span> <span class="co">// decoder</span></code></pre></div>
</div>
<h4 id="latch-implementation">Latch Implementation</h4>
<p>We can easily implement a D-type latch using an <strong>always</strong> block. We will need 5 ports, 3 for input signals ( data in, enable, <span class="math inline">\(\overline{enable}\)</span> ) and 2 for output signals ( q and <span class="math inline">\(\overline{q}\)</span>).</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> dlatch(
    d,q,nq,ena,nena
    );
    
    <span class="dt">input</span>       d;
    <span class="dt">input</span>       ena;
    <span class="dt">input</span>       nena;
    <span class="dt">output</span>  <span class="dt">reg</span> q;
    <span class="dt">output</span>  <span class="dt">reg</span> nq;

    <span class="kw">always</span> @(d,ena,nena) <span class="kw">begin:</span><span class="dt"> d</span>_latch_procedure
        <span class="kw">if</span>(ena) <span class="kw">begin</span>
            q&lt;=d;
            nq&lt;=~d;
        <span class="kw">end</span> <span class="co">// if( le=&#39;1&#39;)</span>
        <span class="kw">else</span> <span class="kw">begin</span>
        <span class="kw">end</span>

    <span class="kw">end</span> <span class="co">// d_latch_procedure</span>

<span class="kw">endmodule</span> <span class="co">// dlatch</span></code></pre></div>
</div>
<h4 id="driver-implementation">Driver Implementation</h4>
<p>The driver will have to set output to 1 if <em>LT</em> (Lamp Test) signal is low, otherwise the output will be transparent to input. In other words, in can be implemented as a latch.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> drv_7seg(
    lt,inbus,outbus
    );

    <span class="dt">input</span>               lt;
    <span class="dt">input</span>       [<span class="dv">7</span>:<span class="dv">0</span>]   inbus;
    <span class="dt">output</span>  <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;

    <span class="kw">always</span> @(lt,inbus) <span class="kw">begin :</span><span class="dt"> d</span>rv_7seg
        <span class="kw">if</span>(lt) <span class="kw">begin</span>
            outbus&lt;=inbus;
        <span class="kw">end</span> <span class="kw">else</span> <span class="kw">begin</span>
            outbus&lt;=<span class="bn">8&#39;b11111111</span>; 
        <span class="kw">end</span>
    <span class="kw">end</span>

<span class="kw">endmodule</span> <span class="co">// drv_7seg</span></code></pre></div>
</div>
<h4 id="modules-instantiation-and-testbench">Modules Instantiation and testbench</h4>
<p>Now that we have all the modules defined we can create a new module <strong>driver_7_segments</strong> and instantiate them.</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> driver_7_segments(
    inbus,le,lt,bl,outbus,
    );
    
    <span class="dt">input</span>       [<span class="dv">3</span>:<span class="dv">0</span>]   inbus;      <span class="co">//input data</span>
    <span class="dt">input</span>               le;             <span class="co">//latch-enable</span>
    <span class="dt">input</span>               lt;             <span class="co">//lamp-test-&gt;displays 8</span>
    <span class="dt">input</span>               bl;             <span class="co">//blanking-&gt; blank</span>
    <span class="dt">output</span> <span class="dt">reg</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;


    <span class="dt">wire</span> [<span class="dv">3</span>:<span class="dv">0</span>]  latch_output;
    <span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>]  decoder_output;

    dlatch latch0(.d  (inbus[<span class="dv">0</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">0</span>]),.nq ());
    
    dlatch latch1(.d  (inbus[<span class="dv">1</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">1</span>]),.nq ());
    
    dlatch latch2(.d  (inbus[<span class="dv">2</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">2</span>]),.nq ());

    dlatch latch3(.d  (inbus[<span class="dv">3</span>]),.ena (~le),.nena(le),.q  (latch_output[<span class="dv">3</span>]),.nq ());
    
    dec_7seg decoder_7_segments(.datain (latch_output),.bl     (bl),.dataout(decoder_output));
    
    drv_7seg driver_7_segments(.inbus (decoder_output),.lt    (lt),.outbus(outbus));
   
<span class="kw">endmodule</span> <span class="co">// segments_driver</span></code></pre></div>
</div>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="ot">`include </span><span class="fl">&quot;testbench/test_inc.v&quot;</span>
<span class="kw">module</span> driver_7_segments_tb;

	<span class="dt">reg</span>       [<span class="dv">3</span>:<span class="dv">0</span>]   inbus;      <span class="co">//input data</span>
    <span class="dt">reg</span>               le;             <span class="co">//latch-enable</span>
    <span class="dt">reg</span>               lt;             <span class="co">//lamp-test-&gt;displays 8</span>
    <span class="dt">reg</span>               bl;             <span class="co">//blanking-&gt; blank</span>
    <span class="dt">wire</span> <span class="dt">reg</span>  [<span class="dv">7</span>:<span class="dv">0</span>]   outbus;

    driver_7_segments driver(.inbus (inbus),.le (le),.lt (lt),.bl (bl),.outbus(outbus));

    <span class="kw">initial</span> <span class="kw">begin</span>
        <span class="dt">$dumpfile</span>(<span class="st">&quot;segments_driver_tb.vcd&quot;</span>);
        <span class="dt">$dumpvars</span>;

        <span class="co">//Lamp Test</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//blanking is disabled</span>
        inbus&lt;=<span class="bn">4&#39;b0000</span>;<span class="co">//0 on inbus</span>
        lt&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//lamp test enabled</span>
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111111</span>);

        <span class="bn">#50</span> 
        <span class="co">//Blanking Test</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//blanking is enabled</span>
		inbus&lt;=<span class="bn">4&#39;b0000</span>;<span class="co">//0 on inbus</span>
        lt&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//lamp test disabled</span>
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b00000000</span>);        

        <span class="bn">#50</span>
        <span class="co">//test all values</span>
        le&lt;=<span class="bn">1&#39;b0</span>;<span class="co">//latch is transparent</span>
        bl&lt;=<span class="bn">1&#39;b1</span>;<span class="co">//blanking is disabled</span>
        lt&lt;=<span class="bn">1&#39;b1</span>; <span class="co">//lamp test is disabled</span>
        
        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0000</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111100</span>);
		
		<span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0001</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b01100000</span>);

		<span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0010</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11011010</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0011</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11110010</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0100</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b01100110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0101</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b10110110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0110</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b10111110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b0111</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11100000</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b1000</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11111110</span>);

        <span class="bn">#25</span> inbus&lt;=<span class="bn">4&#39;b1001</span>;
        <span class="bn">#25</span> <span class="ot">`assert</span>(outbus,<span class="bn">8&#39;b11110110</span>);
    <span class="kw">end</span> <span class="co">// initial</span>

    <span class="kw">initial</span> <span class="kw">begin :</span><span class="dt">d</span>ump_proc
            <span class="dt">$display</span>(<span class="st">&quot;</span><span class="ch">\t\t</span><span class="st">Time</span><span class="ch">\t</span><span class="st">INBUS</span><span class="ch">\t</span><span class="st">/LE</span><span class="ch">\t</span><span class="st">/LT</span><span class="ch">\t</span><span class="st">/BL</span><span class="ch">\t</span><span class="st">OUTBUS&quot;</span>);
            <span class="dt">$monitor</span>(<span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b</span><span class="ch">\t</span><span class="st">%b&quot;</span>,<span class="dt">$time</span>,inbus,le,lt,bl,outbus);
    <span class="kw">end</span> <span class="co">// dump_proc</span>
<span class="kw">endmodule</span> <span class="co">// segments_driver_tb</span></code></pre></div>
</div>
<hr />
<h3 id="bibliography">Bibliography</h3>
<ol style="list-style-type: decimal">
<li><a href="http://www.ti.com/lit/ds/symlink/cd74hc4511.pdf">TI HC4511 Datasheet</a></li>
<li><a href="https://www.electronicshub.org/bcd-7-segment-led-display-decoder-circuit/">Electronics Hub</a></li>
<li><a href="https://www.electronics-tutorials.ws/combination/comb_6.html">Electronics Tutorials</a></li>
</ol>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>]]></summary>
</entry>
<entry>
    <title>Monte Carlo Pi Estimation</title>
    <link href="http://ardeleanasm.github.io/posts/2018-02-15-Monte-Carlo-Pi-Estimation.html" />
    <id>http://ardeleanasm.github.io/posts/2018-02-15-Monte-Carlo-Pi-Estimation.html</id>
    <published>2018-02-15T00:00:00Z</published>
    <updated>2018-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[A Monte Carlo Pi estimation algorithm implemented in F#]]></summary>
</entry>
<entry>
    <title>2018-02-15-Monte-Carlo-Pi-Estimation</title>
    <link href="http://ardeleanasm.github.io/posts/2018-02-15-Monte-Carlo-Pi-Estimation.html" />
    <id>http://ardeleanasm.github.io/posts/2018-02-15-Monte-Carlo-Pi-Estimation.html</id>
    <published>2018-02-15T00:00:00Z</published>
    <updated>2018-02-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!--<article>
    <section class="header">
        Posted on February 15, 2018
        
    </section>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="monte-carlo-pi-estimation">Monte Carlo Pi Estimation</h1>
<div class="section header">
Posted on February 15, 2018
</div>
<div class="info">
Tags: <a href="../tags/fsharp.html">fsharp</a>
</div>
<div class="section">
<p>In this post I’ll show how Pi can be computed using a Monte Carlo algorithm in F#. Basically, using the idea of a dartboard we can obtain the value of PI by simply calculating the number of darts that land in the dartboard verses those that land outside it. And by increasing the number of throws we will get closer to PI’s value, for example throwing the dart 1000 times will be closer to PI than throwing the dart 10 or 100 times.</p>
<p>The formula that we will use to determine PI by throwing darts is:</p>
<p><span class="math display">\[PI=4.0*\frac{hits}{darts thrown}\]</span></p>
<p>In our implementation in F# we will have 3 simple functions. We start by defining a function that will generate random numbers as</p>
<pre class="f#"><code>let rnd=System.Random(System.DateTime.Now.Millisecond)

let genRandomNumbers (count:int) =
    List.init count (fun _ -&gt; rnd.NextDouble ())</code></pre>
<p>We initialize a System.Random object and we use it in <code>getRandomNumbers</code> to generate a value in interval [0,1]. The next thing we will have to do is to implement a function that will check if the thrown dart is in the dartboard or not. The function will have to return true if the distance between the coordinate of the dart and the center of the circle is less than 1, otherwise false.</p>
<pre class="f#"><code>let isInside (x:double) (y:double)=(sqrt (x*x+y*y))&lt;1.0</code></pre>
<p>The third function is just a helper to check if the generated coordinate is inside the circle or not.</p>
<pre class="f#"><code>let sum (x:^a list)=
    match (isInside (x.Head*2.0-1.0) (x.Tail.Head*2.0-1.0)) with
        | false-&gt;0
        | true-&gt; 1</code></pre>
<p>Finally, we will implement a recursive function that computes PI. This function will take as arguments the number of throws, number of hits ( initially 0) and an index ( initially 0). If index value ( idx) reaches number of throws then we will return the value we calculated with the above formula. If not, then we will recursively call the function with <code>hits+1</code> if the newly generated number is inside the circle and with <code>idx+1</code>.</p>
<pre class="f#"><code>let rec computePi (numThrows:int) (hits:int) (idx:int)=
    if numThrows=idx then
        4.0*((double)hits/(double)numThrows)
    else
          computePi numThrows (hits+(genRandomNumbers 2 |&gt; sum)) (idx+1) </code></pre>
<p>And now, we can calculate PI:</p>
<pre class="f#"><code>[&lt;EntryPoint&gt;]
let main argv = 
    let l=computePi 1000000000 0 0
    printfn &quot;%F&quot; l
    0</code></pre>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on February 15, 2018
        
    </section>
    <div class="info">
        
        Tags: 
        
    </div>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="monte-carlo-pi-estimation">Monte Carlo Pi Estimation</h1>
<div class="section header">
Posted on February 15, 2018
</div>
<div class="info">
Tags: <a href="../tags/fsharp.html">fsharp</a>
</div>
<div class="section">
<p>In this post I’ll show how Pi can be computed using a Monte Carlo algorithm in F#. Basically, using the idea of a dartboard we can obtain the value of PI by simply calculating the number of darts that land in the dartboard verses those that land outside it. And by increasing the number of throws we will get closer to PI’s value, for example throwing the dart 1000 times will be closer to PI than throwing the dart 10 or 100 times.</p>
<p>The formula that we will use to determine PI by throwing darts is:</p>
<p><span class="math display">\[PI=4.0*\frac{hits}{darts thrown}\]</span></p>
<p>In our implementation in F# we will have 3 simple functions. We start by defining a function that will generate random numbers as</p>
<pre class="f#"><code>let rnd=System.Random(System.DateTime.Now.Millisecond)

let genRandomNumbers (count:int) =
    List.init count (fun _ -&gt; rnd.NextDouble ())</code></pre>
<p>We initialize a System.Random object and we use it in <code>getRandomNumbers</code> to generate a value in interval [0,1]. The next thing we will have to do is to implement a function that will check if the thrown dart is in the dartboard or not. The function will have to return true if the distance between the coordinate of the dart and the center of the circle is less than 1, otherwise false.</p>
<pre class="f#"><code>let isInside (x:double) (y:double)=(sqrt (x*x+y*y))&lt;1.0</code></pre>
<p>The third function is just a helper to check if the generated coordinate is inside the circle or not.</p>
<pre class="f#"><code>let sum (x:^a list)=
    match (isInside (x.Head*2.0-1.0) (x.Tail.Head*2.0-1.0)) with
        | false-&gt;0
        | true-&gt; 1</code></pre>
<p>Finally, we will implement a recursive function that computes PI. This function will take as arguments the number of throws, number of hits ( initially 0) and an index ( initially 0). If index value ( idx) reaches number of throws then we will return the value we calculated with the above formula. If not, then we will recursively call the function with <code>hits+1</code> if the newly generated number is inside the circle and with <code>idx+1</code>.</p>
<pre class="f#"><code>let rec computePi (numThrows:int) (hits:int) (idx:int)=
    if numThrows=idx then
        4.0*((double)hits/(double)numThrows)
    else
          computePi numThrows (hits+(genRandomNumbers 2 |&gt; sum)) (idx+1) </code></pre>
<p>And now, we can calculate PI:</p>
<pre class="f#"><code>[&lt;EntryPoint&gt;]
let main argv = 
    let l=computePi 1000000000 0 0
    printfn &quot;%F&quot; l
    0</code></pre>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>]]></summary>
</entry>
<entry>
    <title>Polynomial Value in Haskell</title>
    <link href="http://ardeleanasm.github.io/posts/2017-11-30-Polynomial-Value-in-Haskell.html" />
    <id>http://ardeleanasm.github.io/posts/2017-11-30-Polynomial-Value-in-Haskell.html</id>
    <published>2017-11-30T00:00:00Z</published>
    <updated>2017-11-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[]]></summary>
</entry>
<entry>
    <title>2017-11-30-Polynomial-Value-in-Haskell</title>
    <link href="http://ardeleanasm.github.io/posts/2017-11-30-Polynomial-Value-in-Haskell.html" />
    <id>http://ardeleanasm.github.io/posts/2017-11-30-Polynomial-Value-in-Haskell.html</id>
    <published>2017-11-30T00:00:00Z</published>
    <updated>2017-11-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!--<article>
    <section class="header">
        Posted on November 30, 2017
        
    </section>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="polynomial-value-in-haskell">Polynomial Value in Haskell</h1>
<div class="section header">
Posted on November 30, 2017
</div>
<div class="info">
Tags: <a href="../tags/haskell.html">haskell</a>
</div>
<div class="section">
<p>While working on a project that analyze some signals in Haskell I found that I need a simple function <code>polyVal</code> that evaluates a polynomial at specific values.</p>
<p>After a failed search for this function ( I thought that I can find a library or an implementation) I decided to write it on my own, anyway, it’s a simple function.</p>
<p>So, let’s suppose we have a polynomial <em>p</em> of degree <em>N</em>, this function returns the value:</p>
<p><span class="math display">\[p_{0}*x^{N-1}+p_{1}*x^{N-2}+…+p_{N-2}*x+p_{N-1}\]</span></p>
<p>The Haskell implementation of this function is:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalPoly::</span><span class="dt">Double</span><span class="ot">-&gt;</span>[<span class="dt">Double</span>]<span class="ot">-&gt;</span><span class="dt">Double</span>
evalPoly n xs<span class="fu">=</span>sum <span class="fu">$</span> map (\e<span class="ot">-&gt;</span>e<span class="fu">*</span>n<span class="fu">**</span>fromIntegral ((length xs)<span class="fu">-</span><span class="dv">1</span><span class="fu">-</span>(fromJust <span class="fu">$</span> elemIndex e xs))) xs</code></pre></div>
</div>
<p>Example of ussage:</p>
<pre><code>&gt;evalPoly 3 [-19,7,-4,6]
-456.0
&gt;evalPoly 5 [3,0,1]
76.0</code></pre>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on November 30, 2017
        
    </section>
    <div class="info">
        
        Tags: 
        
    </div>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="polynomial-value-in-haskell">Polynomial Value in Haskell</h1>
<div class="section header">
Posted on November 30, 2017
</div>
<div class="info">
Tags: <a href="../tags/haskell.html">haskell</a>
</div>
<div class="section">
<p>While working on a project that analyze some signals in Haskell I found that I need a simple function <code>polyVal</code> that evaluates a polynomial at specific values.</p>
<p>After a failed search for this function ( I thought that I can find a library or an implementation) I decided to write it on my own, anyway, it’s a simple function.</p>
<p>So, let’s suppose we have a polynomial <em>p</em> of degree <em>N</em>, this function returns the value:</p>
<p><span class="math display">\[p_{0}*x^{N-1}+p_{1}*x^{N-2}+…+p_{N-2}*x+p_{N-1}\]</span></p>
<p>The Haskell implementation of this function is:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalPoly::</span><span class="dt">Double</span><span class="ot">-&gt;</span>[<span class="dt">Double</span>]<span class="ot">-&gt;</span><span class="dt">Double</span>
evalPoly n xs<span class="fu">=</span>sum <span class="fu">$</span> map (\e<span class="ot">-&gt;</span>e<span class="fu">*</span>n<span class="fu">**</span>fromIntegral ((length xs)<span class="fu">-</span><span class="dv">1</span><span class="fu">-</span>(fromJust <span class="fu">$</span> elemIndex e xs))) xs</code></pre></div>
</div>
<p>Example of ussage:</p>
<pre><code>&gt;evalPoly 3 [-19,7,-4,6]
-456.0
&gt;evalPoly 5 [3,0,1]
76.0</code></pre>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>]]></summary>
</entry>
<entry>
    <title>How to transform a List to a Map in Scala</title>
    <link href="http://ardeleanasm.github.io/posts/2017-10-17-How-to-transform-list-to-map-in-Scala.html" />
    <id>http://ardeleanasm.github.io/posts/2017-10-17-How-to-transform-list-to-map-in-Scala.html</id>
    <published>2017-10-17T00:00:00Z</published>
    <updated>2017-10-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[]]></summary>
</entry>
<entry>
    <title>2017-10-17-How-to-transform-list-to-map-in-Scala</title>
    <link href="http://ardeleanasm.github.io/posts/2017-10-17-How-to-transform-list-to-map-in-Scala.html" />
    <id>http://ardeleanasm.github.io/posts/2017-10-17-How-to-transform-list-to-map-in-Scala.html</id>
    <published>2017-10-17T00:00:00Z</published>
    <updated>2017-10-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!--<article>
    <section class="header">
        Posted on October 17, 2017
        
    </section>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="how-to-transform-a-list-to-a-map-in-scala">How to transform a List to a Map in Scala</h1>
<div class="section header">
Posted on October 17, 2017
</div>
<div class="info">
Tags: <a href="../tags/scala.html">scala</a>
</div>
<div class="section">
<p>Yesterday I faced a new, for me at least, problem when I wanted to read a file line by line into a List and transform the result to a Map.</p>
<p>Basically, I had a file ( from Rosalind) like the one below, a file in FASTA format.</p>
<pre><code>&gt;Tag_XXXX
string
&gt;Tag_YYYY
string
&gt;Tag_ZZZZ
string</code></pre>
<p>A FASTA file contains a labels that starts with ‘&gt;’ character and the associated information on the next line. So it seemed normally to use a Map instead of a List.</p>
<p>So, I started by reading the file in a <code>List[String]</code></p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> lines: Option[List[String]] = {
    <span class="kw">if</span> (Files.<span class="fu">exists</span>(Paths.<span class="fu">get</span>(filePath))) {
      Some(Source.<span class="fu">fromFile</span>(filePath, <span class="st">&quot;UTF-8&quot;</span>).<span class="fu">getLines</span>().<span class="fu">toList</span>)
    } <span class="kw">else</span> {
      None
    }</code></pre></div>
</div>
<p>The next step was to zip lines two by two and filter only the one that contains ‘&gt;’</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">lines.<span class="fu">get</span>.<span class="fu">zip</span>(lines.<span class="fu">get</span>.<span class="fu">tail</span>).<span class="fu">filter</span> { <span class="kw">case</span> (k, _) =&gt; k.<span class="fu">contains</span>(<span class="ch">&#39;&gt;&#39;</span>) }</code></pre></div>
</div>
<p>in this way I obtained a list of tuples. The final step was simple because I only had to call toMap function.</p>
<p>Full code can be seen in this <a href="https://github.com/ardeleanasm/bioinformatics">REPO</a>.</p>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on October 17, 2017
        
    </section>
    <div class="info">
        
        Tags: 
        
    </div>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="how-to-transform-a-list-to-a-map-in-scala">How to transform a List to a Map in Scala</h1>
<div class="section header">
Posted on October 17, 2017
</div>
<div class="info">
Tags: <a href="../tags/scala.html">scala</a>
</div>
<div class="section">
<p>Yesterday I faced a new, for me at least, problem when I wanted to read a file line by line into a List and transform the result to a Map.</p>
<p>Basically, I had a file ( from Rosalind) like the one below, a file in FASTA format.</p>
<pre><code>&gt;Tag_XXXX
string
&gt;Tag_YYYY
string
&gt;Tag_ZZZZ
string</code></pre>
<p>A FASTA file contains a labels that starts with ‘&gt;’ character and the associated information on the next line. So it seemed normally to use a Map instead of a List.</p>
<p>So, I started by reading the file in a <code>List[String]</code></p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> lines: Option[List[String]] = {
    <span class="kw">if</span> (Files.<span class="fu">exists</span>(Paths.<span class="fu">get</span>(filePath))) {
      Some(Source.<span class="fu">fromFile</span>(filePath, <span class="st">&quot;UTF-8&quot;</span>).<span class="fu">getLines</span>().<span class="fu">toList</span>)
    } <span class="kw">else</span> {
      None
    }</code></pre></div>
</div>
<p>The next step was to zip lines two by two and filter only the one that contains ‘&gt;’</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">lines.<span class="fu">get</span>.<span class="fu">zip</span>(lines.<span class="fu">get</span>.<span class="fu">tail</span>).<span class="fu">filter</span> { <span class="kw">case</span> (k, _) =&gt; k.<span class="fu">contains</span>(<span class="ch">&#39;&gt;&#39;</span>) }</code></pre></div>
</div>
<p>in this way I obtained a list of tuples. The final step was simple because I only had to call toMap function.</p>
<p>Full code can be seen in this <a href="https://github.com/ardeleanasm/bioinformatics">REPO</a>.</p>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>]]></summary>
</entry>
<entry>
    <title>Quantum Computing in Haskell - IV part</title>
    <link href="http://ardeleanasm.github.io/posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html" />
    <id>http://ardeleanasm.github.io/posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html</id>
    <published>2017-08-18T00:00:00Z</published>
    <updated>2017-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[Quantum Computing with Haskell]]></summary>
</entry>
<entry>
    <title>2017-08-18-Quantum-Computing-in-Haskell-fourth-part</title>
    <link href="http://ardeleanasm.github.io/posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html" />
    <id>http://ardeleanasm.github.io/posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html</id>
    <published>2017-08-18T00:00:00Z</published>
    <updated>2017-08-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!--<article>
    <section class="header">
        Posted on August 18, 2017
        
    </section>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="quantum-computing-in-haskell---iv-part">Quantum Computing in Haskell - IV part</h1>
<div class="section header">
Posted on August 18, 2017
</div>
<div class="info">
Tags: <a href="../tags/haskell.html">haskell</a>
</div>
<div class="section">
<h2 id="articles">Articles</h2>
<ul>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell/">Quantum Computing in Haskell - I part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-second-part/">Quantum Computing in Haskell - II part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-third-part/">Quantum Computing in Haskell - III part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-fourth-part/">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous articles, first three parts, I presented some haskell code to implement basic operators for simulating Quantum Algorithms. The full source code can be downloaded from <a href="https://github.com/ardeleanasm/qchas">Github Repository</a>. The library was also published on <a href="https://hackage.haskell.org/package/qchas">Hackage</a> and also on <a href="https://www.stackage.org/nightly-2017-08-17/package/qchas-1.0.1.0">Stackage</a> and is available with 2 versions, 1.0.0 and 1.0.1.0. Starting from version 1.0.1.0 the <strong>Utils</strong> module was removed and also, a new module for performing measurements was added. These articles will be also used as documentation/ wiki for the library.</p>
<p>In this fourth part we will start to present some Quantum Algorithms and we will start with one of the simplest ones, Deutsch’s algorithm. In the next articles from the serie we will talk about Deutsch-Jozsa’s algorithm, Grover’s and Shor.</p>
<h2 id="background">Background</h2>
<p>As I said in a previous article when I implemented this algorithm in Java, the problem that Deutsch’s algorithm solves is not an important one in Computer Science but it’s a good example to see the power of quantum computers, being solved by a quantum computer faster than by a traditional one, although not exponentially faster.</p>
<p>So, let’s suppose that we have a function f with 1-bit input and 1-bit output. There are four possible functions, two of them are constant and two are balanced, as we can see in the table below.</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f_{1}(0)=0, f_{1}(1)=0\)</span></td>
<td>constant</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f_{2}(0)=1, f_{2}(1)=1\)</span></td>
<td>constant</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(f_{3}(0)=0, f_{3}(1)=1\)</span></td>
<td>balanced</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f_{4}(0)=1, f_{4}(1)=0\)</span></td>
<td>balanced</td>
</tr>
</tbody>
</table>
<p>The goal is to determine whether the function is constant or not. Let’s say that we implement such a function on a classic computer:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main::</span><span class="dt">IO</span> ()
main<span class="fu">=</span><span class="kw">do</span>
  print <span class="fu">$</span> testFunction f1
  print <span class="fu">$</span> testFunction f2
  print <span class="fu">$</span> testFunction f3
  print <span class="fu">$</span> testFunction f4

<span class="ot">f1::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f1 val<span class="fu">=</span><span class="dv">0</span>

<span class="ot">f2::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f2 val<span class="fu">=</span><span class="dv">1</span>

<span class="ot">f3::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f3 val<span class="fu">=</span>val

<span class="ot">f4::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f4 val
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">1</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">testFunction::</span>(<span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>)<span class="ot">-&gt;</span><span class="dt">String</span>
testFunction f
  <span class="fu">|</span>f <span class="dv">0</span> <span class="fu">==</span> f <span class="dv">1</span><span class="fu">=</span> <span class="st">&quot;Constant&quot;</span>
  <span class="fu">|</span>otherwise<span class="fu">=</span> <span class="st">&quot;Balanced&quot;</span></code></pre></div>
</div>
<p>and the output will be:</p>
<pre><code>&quot;Constant&quot;
&quot;Constant&quot;
&quot;Balanced&quot;
&quot;Balanced&quot;</code></pre>
<p>It can be easily seen that to check if a function is constant or balanced on a classical computer we need two calls to that function, basically we evaluate the function twice. We will see next that by using Deutsch’s algorithm the problem can be solved by evaluating the function only once.</p>
<div class="figure">
<img src="http://ardeleanasm.github.io/resources/deutsch_quantum_circuits.png" alt="The quantum circuit of Deutsch’s algorithm1" />
<p>The quantum circuit of Deutsch’s algorithm<a href="https://github.com/ardeleanasm/qchas">1</a></p>
</div>
<p>The quantum circuit that we will have to implement can be seen in the picture above and basically we will have to:</p>
<ul>
<li>Apply <strong>X-Gate</strong> on the second qubit</li>
<li>Apply <span class="math inline">\(H^2\)</span> gate, the Kronecker product between two <strong>Hadamard</strong> Gates</li>
<li>Apply the gate ( or “oracle”) <span class="math inline">\(U_f\)</span></li>
<li>Apply Hadamard Gate again on the first qubit</li>
<li>Measure the circuit</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>First of all, let’s define the unitary transformations for all four functions:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--f(0)=0 and f(1)=0</span>
<span class="ot">f1::</span><span class="dt">Gate</span>
f1<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=1</span>
<span class="ot">f2::</span><span class="dt">Gate</span>
f2<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=0 and f(1)=1</span>
<span class="ot">f3::</span><span class="dt">Gate</span>
f3<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=0</span>
<span class="ot">f4::</span><span class="dt">Gate</span>
f4<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)                </code></pre></div>
</div>
<p>The next step is to define a function that will test all the four functions:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testDeutschsAlgorithm::</span><span class="dt">IO</span>()
testDeutschsAlgorithm<span class="fu">=</span>mapM_ deutsch [f1,f2,f3,f4]</code></pre></div>
</div>
<p>Now, let’s implement the algorithm:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deutsch::</span><span class="dt">Gate</span><span class="ot">-&gt;</span><span class="dt">IO</span>()
deutsch oracle<span class="fu">=</span><span class="kw">do</span> <span class="kw">let</span> (result<span class="fu">:</span>_)<span class="fu">=</span>measure circuit
                  <span class="kw">case</span> result <span class="kw">of</span>
                    <span class="ch">&#39;0&#39;</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is constant&quot;</span>
                    <span class="ch">&#39;1&#39;</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is balanced&quot;</span>
                    _   <span class="ot">-&gt;</span> return()
    <span class="kw">where</span>
        gateHadamardOnTwoQubits<span class="fu">=</span>(hGate <span class="fu">&lt;+&gt;</span> hGate)
        circuit<span class="fu">=</span>entangle qZero (qZero <span class="fu">|&gt;</span> xGate) <span class="fu">|&gt;</span> gateHadamardOnTwoQubits <span class="fu">|&gt;</span> oracle <span class="fu">|&gt;</span> gateHadamardOnTwoQubits
        measure q<span class="fu">=</span><span class="kw">let</span> result<span class="fu">=</span>map(\c<span class="ot">-&gt;</span>round (realPart (c <span class="fu">*</span> conjugate c))) (toList <span class="fu">.</span> flatten <span class="fu">$</span> qubitState q)        
                  <span class="kw">in</span> <span class="kw">case</span> result <span class="kw">of</span>
                    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]<span class="ot">-&gt;</span><span class="st">&quot;01&quot;</span>
                    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">-&gt;</span><span class="st">&quot;11&quot;</span>
                    _        <span class="ot">-&gt;</span><span class="st">&quot;??&quot;</span></code></pre></div>
</div>
<p>If we run the code we will have:</p>
<pre><code>ghci&gt;testDeutschsAlgorithm
Function is constant
Function is constant
Function is balanced
Function is balanced</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>As we can see in this first example, running an algorithm, even a simple one, on a quantum computer can be faster than running it on a classical computer.</p>
<p>About the implemented library, as I said, you can download it from the links that I specified before and these articles and examples of code will be used as a “How to use..” for the library.</p>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on August 18, 2017
        
    </section>
    <div class="info">
        
        Tags: 
        
    </div>
    <section>
        <div class="logo">
<a href="../">My Hakyll Blog</a>
</div>
<p><a href="../">Home</a> <a href="../about.html">About</a> <a href="../contact.html">Contact</a> <a href="../archive.html">Archive</a></p>
<h1 id="quantum-computing-in-haskell---iv-part">Quantum Computing in Haskell - IV part</h1>
<div class="section header">
Posted on August 18, 2017
</div>
<div class="info">
Tags: <a href="../tags/haskell.html">haskell</a>
</div>
<div class="section">
<h2 id="articles">Articles</h2>
<ul>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell/">Quantum Computing in Haskell - I part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-second-part/">Quantum Computing in Haskell - II part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-third-part/">Quantum Computing in Haskell - III part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-fourth-part/">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous articles, first three parts, I presented some haskell code to implement basic operators for simulating Quantum Algorithms. The full source code can be downloaded from <a href="https://github.com/ardeleanasm/qchas">Github Repository</a>. The library was also published on <a href="https://hackage.haskell.org/package/qchas">Hackage</a> and also on <a href="https://www.stackage.org/nightly-2017-08-17/package/qchas-1.0.1.0">Stackage</a> and is available with 2 versions, 1.0.0 and 1.0.1.0. Starting from version 1.0.1.0 the <strong>Utils</strong> module was removed and also, a new module for performing measurements was added. These articles will be also used as documentation/ wiki for the library.</p>
<p>In this fourth part we will start to present some Quantum Algorithms and we will start with one of the simplest ones, Deutsch’s algorithm. In the next articles from the serie we will talk about Deutsch-Jozsa’s algorithm, Grover’s and Shor.</p>
<h2 id="background">Background</h2>
<p>As I said in a previous article when I implemented this algorithm in Java, the problem that Deutsch’s algorithm solves is not an important one in Computer Science but it’s a good example to see the power of quantum computers, being solved by a quantum computer faster than by a traditional one, although not exponentially faster.</p>
<p>So, let’s suppose that we have a function f with 1-bit input and 1-bit output. There are four possible functions, two of them are constant and two are balanced, as we can see in the table below.</p>
<table>
<thead>
<tr class="header">
<th>Function</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f_{1}(0)=0, f_{1}(1)=0\)</span></td>
<td>constant</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f_{2}(0)=1, f_{2}(1)=1\)</span></td>
<td>constant</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(f_{3}(0)=0, f_{3}(1)=1\)</span></td>
<td>balanced</td>
</tr>
<tr class="even">
<td><span class="math inline">\(f_{4}(0)=1, f_{4}(1)=0\)</span></td>
<td>balanced</td>
</tr>
</tbody>
</table>
<p>The goal is to determine whether the function is constant or not. Let’s say that we implement such a function on a classic computer:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main::</span><span class="dt">IO</span> ()
main<span class="fu">=</span><span class="kw">do</span>
  print <span class="fu">$</span> testFunction f1
  print <span class="fu">$</span> testFunction f2
  print <span class="fu">$</span> testFunction f3
  print <span class="fu">$</span> testFunction f4

<span class="ot">f1::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f1 val<span class="fu">=</span><span class="dv">0</span>

<span class="ot">f2::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f2 val<span class="fu">=</span><span class="dv">1</span>

<span class="ot">f3::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f3 val<span class="fu">=</span>val

<span class="ot">f4::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f4 val
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">1</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">testFunction::</span>(<span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>)<span class="ot">-&gt;</span><span class="dt">String</span>
testFunction f
  <span class="fu">|</span>f <span class="dv">0</span> <span class="fu">==</span> f <span class="dv">1</span><span class="fu">=</span> <span class="st">&quot;Constant&quot;</span>
  <span class="fu">|</span>otherwise<span class="fu">=</span> <span class="st">&quot;Balanced&quot;</span></code></pre></div>
</div>
<p>and the output will be:</p>
<pre><code>&quot;Constant&quot;
&quot;Constant&quot;
&quot;Balanced&quot;
&quot;Balanced&quot;</code></pre>
<p>It can be easily seen that to check if a function is constant or balanced on a classical computer we need two calls to that function, basically we evaluate the function twice. We will see next that by using Deutsch’s algorithm the problem can be solved by evaluating the function only once.</p>
<div class="figure">
<img src="http://ardeleanasm.github.io/resources/deutsch_quantum_circuits.png" alt="The quantum circuit of Deutsch’s algorithm1" />
<p>The quantum circuit of Deutsch’s algorithm<a href="https://github.com/ardeleanasm/qchas">1</a></p>
</div>
<p>The quantum circuit that we will have to implement can be seen in the picture above and basically we will have to:</p>
<ul>
<li>Apply <strong>X-Gate</strong> on the second qubit</li>
<li>Apply <span class="math inline">\(H^2\)</span> gate, the Kronecker product between two <strong>Hadamard</strong> Gates</li>
<li>Apply the gate ( or “oracle”) <span class="math inline">\(U_f\)</span></li>
<li>Apply Hadamard Gate again on the first qubit</li>
<li>Measure the circuit</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>First of all, let’s define the unitary transformations for all four functions:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--f(0)=0 and f(1)=0</span>
<span class="ot">f1::</span><span class="dt">Gate</span>
f1<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=1</span>
<span class="ot">f2::</span><span class="dt">Gate</span>
f2<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=0 and f(1)=1</span>
<span class="ot">f3::</span><span class="dt">Gate</span>
f3<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=0</span>
<span class="ot">f4::</span><span class="dt">Gate</span>
f4<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)                </code></pre></div>
</div>
<p>The next step is to define a function that will test all the four functions:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testDeutschsAlgorithm::</span><span class="dt">IO</span>()
testDeutschsAlgorithm<span class="fu">=</span>mapM_ deutsch [f1,f2,f3,f4]</code></pre></div>
</div>
<p>Now, let’s implement the algorithm:</p>
<div class="sourceCode">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deutsch::</span><span class="dt">Gate</span><span class="ot">-&gt;</span><span class="dt">IO</span>()
deutsch oracle<span class="fu">=</span><span class="kw">do</span> <span class="kw">let</span> (result<span class="fu">:</span>_)<span class="fu">=</span>measure circuit
                  <span class="kw">case</span> result <span class="kw">of</span>
                    <span class="ch">&#39;0&#39;</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is constant&quot;</span>
                    <span class="ch">&#39;1&#39;</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is balanced&quot;</span>
                    _   <span class="ot">-&gt;</span> return()
    <span class="kw">where</span>
        gateHadamardOnTwoQubits<span class="fu">=</span>(hGate <span class="fu">&lt;+&gt;</span> hGate)
        circuit<span class="fu">=</span>entangle qZero (qZero <span class="fu">|&gt;</span> xGate) <span class="fu">|&gt;</span> gateHadamardOnTwoQubits <span class="fu">|&gt;</span> oracle <span class="fu">|&gt;</span> gateHadamardOnTwoQubits
        measure q<span class="fu">=</span><span class="kw">let</span> result<span class="fu">=</span>map(\c<span class="ot">-&gt;</span>round (realPart (c <span class="fu">*</span> conjugate c))) (toList <span class="fu">.</span> flatten <span class="fu">$</span> qubitState q)        
                  <span class="kw">in</span> <span class="kw">case</span> result <span class="kw">of</span>
                    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]<span class="ot">-&gt;</span><span class="st">&quot;01&quot;</span>
                    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">-&gt;</span><span class="st">&quot;11&quot;</span>
                    _        <span class="ot">-&gt;</span><span class="st">&quot;??&quot;</span></code></pre></div>
</div>
<p>If we run the code we will have:</p>
<pre><code>ghci&gt;testDeutschsAlgorithm
Function is constant
Function is constant
Function is balanced
Function is balanced</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>As we can see in this first example, running an algorithm, even a simple one, on a quantum computer can be faster than running it on a classical computer.</p>
<p>About the implemented library, as I said, you can download it from the links that I specified before and these articles and examples of code will be used as a “How to use..” for the library.</p>
</div>
<p><a href="https://github.com/ardeleanasm"><em></em></a> <a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><em></em></a> <a href="https://ardeleanasm.github.io/feed.xml"><em></em></a> <a href="https://www.twitter.com/mihaiseba"><em></em></a> <a href="http://stackoverflow.com/users/1462225/23ars"><em></em></a> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
    </section>
</article>]]></summary>
</entry>

</feed>
