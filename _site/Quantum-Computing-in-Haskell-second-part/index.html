<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1" />


	<title>Quantum Computing in Haskell - II part · Just Computer Engineering</title>


<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@mihaiseba" />
<meta name="twitter:title" content="Quantum Computing in Haskell - II part" />
<meta name="twitter:description" content="Articles">

<meta name="description" content="Articles">



<link rel="icon" href="/assets/favicon.png">
<link rel="apple-touch-icon" href="/assets/touch-icon.png">
<link rel="stylesheet" href="/assets/core.css">
<link rel="canonical" href="/Quantum-Computing-in-Haskell-second-part/">
<link rel="alternate" type="application/atom+xml" title="Just Computer Engineering" href="/feed.xml" />




<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


		<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54128414-2', 'auto');
  ga('send', 'pageview');

</script>
	</head>

	<body>

		<aside class="logo">

	

	<a href="/">
		<img src="http://www.gravatar.com/avatar/0afb9a47eb6654437c6986283cff151c.png?s=80" class="gravatar">
	</a>
</aside>
<div align="center">
	<a href="/">Home</a>
	<a href="/about">About</a>
	<a href="/articles">Articles</a>
	<a href="https://github.com/ardeleanasm" target="_blank">Projects</a>
	<a href="/archive">Archive</a>
	<a href="/categories">Categories</a>
	<a href="/tags">Tags</a>
    
</div>
<div align="center">
	<p><article><font color="blue">
</font></article></p>
</div>	


		<article>
			<article>

	<div class="center">
		<h1>Quantum Computing in Haskell - II part</h1>
		<time>July 28, 2017</time>
	</div>

	<div class="divider"></div>

	<h2 id="articles">Articles</h2>

<ul>
  <li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell/">Quantum Computing in Haskell - I part</a></li>
  <li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-second-part/">Quantum Computing in Haskell - II part</a></li>
  <li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-third-part/">Quantum Computing in Haskell - III part</a></li>
  <li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-fourth-part/">Quantum Computing in Haskell - IV part</a></li>
  <li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
  <li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
  <li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>In the first article from this series I presented some basic math and I suggest reading that article first if someone is not familiar with the topic of Quantum Computing. In this article, the second from the series I will present the implementation in Haskell. The plan is that after a few articles in which I will present the data types, modules, functions, we will implement some Quantum algorithms like Deutsch’s Algorithm, Grover’s Algorithm, Deutsch-Josza’s Algorithm and maybe Shor’s algorithm.</p>

<h2 id="background">Background</h2>

<p>We saw in the previous article that the state of a qubit can be described by</p>

<p><script type="math/tex">\newcommand{\ket}[1]{\left|{#1}\right\rangle}</script>
<script type="math/tex">\newcommand{\bra}[1]{\left\langle{#1}\right|}</script>
<script type="math/tex">\ket{v}=\alpha\ket{0}+\beta\ket{1}</script></p>

<p>where</p>

<script type="math/tex; mode=display">{|\alpha|}^2+{|\beta|}^2=1</script>

<p>and</p>

<p><script type="math/tex">\ket{0}=\begin{bmatrix} 1 \\ 0\end{bmatrix}</script>
<script type="math/tex">\ket{1}=\begin{bmatrix} 0 \\ 1\end{bmatrix}</script></p>

<p>It’s clearly, from the above equations, that we have to implement a Qubit type and the qubits <script type="math/tex">\ket{0}</script> and <script type="math/tex">\ket{1}</script>.</p>

<h2 id="implementation">Implementation</h2>

<p>For the implementation in Haskell I chose to use <a href="https://hackage.haskell.org/package/hmatrix">hmatrix</a> library because we will have to work with matrices and vectors and by using this library we won’t have to implement new types and functions that performs the needed operations.</p>

<p>Anyway, a simple solution that don’t use hmatrix is to define our own <strong>matrix</strong> and <strong>vector</strong> types like</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Vector</span> <span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kr">type</span> <span class="kt">Matrix</span> <span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="kt">Vector</span> <span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<p>and also some functions that will create our complex vectors and matrices</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">complexVector</span><span class="o">::</span><span class="kt">Real</span> <span class="n">a</span><span class="o">=&gt;</span><span class="kt">Vector</span> <span class="n">a</span><span class="o">-&gt;</span><span class="kt">Vector</span><span class="p">(</span><span class="kt">Complex</span> <span class="kt">Double</span><span class="p">)</span>
<span class="n">complexVector</span><span class="o">=</span><span class="n">map</span><span class="p">(</span><span class="nf">\</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">realToFrac</span> <span class="n">i</span><span class="o">:+</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">complexMatrix</span><span class="o">::</span><span class="kt">Real</span> <span class="n">a</span><span class="o">=&gt;</span><span class="kt">Matrix</span> <span class="n">a</span><span class="o">-&gt;</span><span class="kt">Matrix</span><span class="p">(</span><span class="kt">Complex</span> <span class="kt">Double</span><span class="p">)</span>
<span class="n">complexMatrix</span><span class="o">=</span><span class="n">map</span> <span class="n">complexVector</span>
</code></pre></div></div>
<p>Since I don’t think that is a feasible approach I won’t discuss the above code. Is nice to know that we can implement it without using hmatrix, is another approach, even the first version of code from repository was implemented this way but it’s a lot of work. I won’t reinvent the wheel, at least for now! :)</p>

<p>Ok, first of all let’s define a new data named <strong>Qubit</strong>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Qubit</span><span class="o">=</span>
    <span class="kt">Qubit</span> <span class="p">{</span>
            <span class="n">qubitState</span><span class="o">::</span><span class="p">(</span><span class="kt">Matrix</span> <span class="kt">C</span><span class="p">)</span> 
          <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>
<p>Our data type has a constructor <strong>Qubit</strong> with one parameter, <strong>qubitState</strong>, of type <strong>complex matrix</strong>, <code class="highlighter-rouge">Matrix C</code>. If we load the above code in <strong>GHCI</strong> we can check the new type that we defined:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt; :t Qubit
Qubit :: Matrix C -&gt; Qubit

</code></pre></div></div>
<p>We can see that Qubit is the data type and the constructors accepts an argument of type <em>Matrix C</em> and returns a <em>Qubit</em>. Ok, now let’s try to create a Qubit.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt;let q=Qubit ((2&gt;&lt;1)[1,0]::Matrix C)
ghci&gt;q
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;qubitState q
(2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]
</code></pre></div></div>

<p>Basically, in the above example we created the <script type="math/tex">\ket{0}</script>. Since in our future examples we will use it a lot alongside <script type="math/tex">\ket{1}</script> we should define some functions that will return them.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qZero</span><span class="o">::</span><span class="kt">Qubit</span>
<span class="n">qZero</span><span class="o">=</span><span class="kt">Qubit</span> <span class="p">((</span><span class="mi">2</span><span class="o">&gt;&lt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">::</span><span class="kt">Matrix</span> <span class="kt">C</span><span class="p">)</span>

<span class="n">qOne</span><span class="o">::</span><span class="kt">Qubit</span>
<span class="n">qOne</span><span class="o">=</span><span class="kt">Qubit</span> <span class="p">((</span><span class="mi">2</span><span class="o">&gt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">::</span><span class="kt">Matrix</span> <span class="kt">C</span><span class="p">)</span>
</code></pre></div></div>

<p>One question that might arise after seeing the code is “Ok, why is Matrix type used instead of Vector?” The answer is quite simple, because we will have to implement, in the next articles, some operations with qubits and gates and is more simple to have the same type for both. Now, if we fire up GHCI and type:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghci&gt;&gt;qZero
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;&gt;qOne
Qubit {qubitState = (2&gt;&lt;1)
 [ 0.0 :+ 0.0
 , 1.0 :+ 0.0 ]}
</code></pre></div></div>
<p>we see that we have two functions that returns our needed qubits.</p>

<p>After the experience that I have with <a href="https://github.com/ardeleanasm/quantum_computing">Java Library for Quantum Computing</a> I think that is useful to also define two more qubits, <script type="math/tex">\ket{+}</script> and <script type="math/tex">\ket{-}</script>. Those qubits can be simply obtained by simply applying the Hadamard Gate on <script type="math/tex">\ket{0}</script> and on <script type="math/tex">\ket{1}</script> respectively.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">qPlus</span><span class="o">::</span><span class="kt">Qubit</span>
<span class="n">qPlus</span><span class="o">=</span><span class="kt">Qubit</span> <span class="p">((</span><span class="mi">2</span><span class="o">&gt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span> <span class="mi">2</span><span class="p">]</span><span class="o">::</span><span class="kt">Matrix</span> <span class="kt">C</span><span class="p">)</span>

<span class="n">qMinus</span><span class="o">::</span><span class="kt">Qubit</span> 
<span class="n">qMinus</span><span class="o">=</span><span class="kt">Qubit</span> <span class="p">((</span><span class="mi">2</span><span class="o">&gt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">sqrt</span> <span class="mi">2</span><span class="p">]</span><span class="o">::</span><span class="kt">Matrix</span> <span class="kt">C</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="conclusions">Conclusions</h2>

<p>For now, we have defined a Qubit type and we can create any qubit. We also define some functions that will create the most used qubits. In future articles we will define a Gate type and we will also implement some operations.</p>

<p>Based on my experience that I have on this topic after doing some research and implementing from scratch a library in Java I was surprised when I saw how fast I can implement this code in Haskell. It was quite simple and it took less time.</p>



	
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>

<div class="page-navigation">
	
    <a class="next" href="/Quantum-Computing-in-Haskell-third-part/" title="NEXT: Quantum Computing in Haskell - III part">&lt;&lt;</a>
		<span> &middot; </span>
  
		<a class="home" href="/" title="Back to Homepage">Home</a>
  
		<span> &middot; </span>
    <a class="prev" href="/Quantum-Computing-in-Haskell/" title="PREV: Quantum Computing in Haskell - I part">&gt;&gt;</a>
  
</div>

		</article>>

		<div class="footer">
  <div align="center">
  <link rel="stylesheet" href="/assets/core.css">





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>

<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>

<a href="/feed.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>

  
  </div>
  <span class="block">&copy; 2019 Mihai Seba</span>
</div>


	</body>

</html>
