<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Bending bits - Quantum Computing in Haskell - II part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-54128414-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-54128414-2');
    </script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">Home</a>
                <a href="../blog.html" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">Blog</a>
                <a href="../archive.html" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        <h2>Quantum Computing in Haskell - II part</h2>
        Posted on July 28, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the first article from this series I presented some basic math and I suggest reading that article first if someone is not familiar with the topic of Quantum Computing. In this article, the second from the series I will present the implementation in Haskell. The plan is that after a few articles in which I will present the data types, modules, functions, we will implement some Quantum algorithms like Deutsch’s Algorithm, Grover’s Algorithm, Deutsch-Josza’s Algorithm and maybe Shor’s algorithm. <!--more--></p>
<h2 id="background">Background</h2>
<p>We saw in the previous article that the state of a qubit can be described by</p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math display">\[\ket{v}=\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where</p>
<p><span class="math display">\[{|\alpha|}^2+{|\beta|}^2=1\]</span></p>
<p>and</p>
<p><span class="math display">\[\ket{0}=\begin{bmatrix} 1 \\ 0\end{bmatrix}\]</span> <span class="math display">\[\ket{1}=\begin{bmatrix} 0 \\ 1\end{bmatrix}\]</span></p>
<p>It’s clearly, from the above equations, that we have to implement a Qubit type and the qubits <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>.</p>
<h2 id="implementation">Implementation</h2>
<p>For the implementation in Haskell I chose to use <a href="https://hackage.haskell.org/package/hmatrix">hmatrix</a> library because we will have to work with matrices and vectors and by using this library we won’t have to implement new types and functions that performs the needed operations.</p>
<p>Anyway, a simple solution that don’t use hmatrix is to define our own <strong>matrix</strong> and <strong>vector</strong> types like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Vector</span> a<span class="fu">=</span>[a]
<span class="kw">type</span> <span class="dt">Matrix</span> a<span class="fu">=</span>[<span class="dt">Vector</span> a]</code></pre></div>
<p>and also some functions that will create our complex vectors and matrices</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">complexVector::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Vector</span> a<span class="ot">-&gt;</span><span class="dt">Vector</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)
complexVector<span class="fu">=</span>map(\i<span class="ot">-&gt;</span>realToFrac i<span class="fu">:+</span><span class="fl">0.0</span>)

<span class="ot">complexMatrix::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Matrix</span> a<span class="ot">-&gt;</span><span class="dt">Matrix</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)
complexMatrix<span class="fu">=</span>map complexVector</code></pre></div>
<p>Since I don’t think that is a feasible approach I won’t discuss the above code. Is nice to know that we can implement it without using hmatrix, is another approach, even the first version of code from repository was implemented this way but it’s a lot of work. I won’t reinvent the wheel, at least for now! :)</p>
<p>Ok, first of all let’s define a new data named <strong>Qubit</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Qubit</span><span class="fu">=</span>
    <span class="dt">Qubit</span> {
<span class="ot">            qubitState::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) 
          } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Our data type has a constructor <strong>Qubit</strong> with one parameter, <strong>qubitState</strong>, of type <strong>complex matrix</strong>, <code>Matrix C</code>. If we load the above code in <strong>GHCI</strong> we can check the new type that we defined:</p>
<pre><code>ghci&gt; :t Qubit
Qubit :: Matrix C -&gt; Qubit
</code></pre>
<p>We can see that Qubit is the data type and the constructors accepts an argument of type <em>Matrix C</em> and returns a <em>Qubit</em>. Ok, now let’s try to create a Qubit.</p>
<pre><code>ghci&gt;let q=Qubit ((2&gt;&lt;1)[1,0]::Matrix C)
ghci&gt;q
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;qubitState q
(2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]</code></pre>
<p>Basically, in the above example we created the <span class="math inline">\(\ket{0}\)</span>. Since in our future examples we will use it a lot alongside <span class="math inline">\(\ket{1}\)</span> we should define some functions that will return them.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qZero::</span><span class="dt">Qubit</span>
qZero<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>)[<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">qOne::</span><span class="dt">Qubit</span>
qOne<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<p>One question that might arise after seeing the code is “Ok, why is Matrix type used instead of Vector?” The answer is quite simple, because we will have to implement, in the next articles, some operations with qubits and gates and is more simple to have the same type for both. Now, if we fire up GHCI and type:</p>
<pre><code>ghci&gt;&gt;qZero
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;&gt;qOne
Qubit {qubitState = (2&gt;&lt;1)
 [ 0.0 :+ 0.0
 , 1.0 :+ 0.0 ]}</code></pre>
<p>we see that we have two functions that returns our needed qubits.</p>
<p>After the experience that I have with <a href="https://github.com/ardeleanasm/quantum_computing">Java Library for Quantum Computing</a> I think that is useful to also define two more qubits, <span class="math inline">\(\ket{+}\)</span> and <span class="math inline">\(\ket{-}\)</span>. Those qubits can be simply obtained by simply applying the Hadamard Gate on <span class="math inline">\(\ket{0}\)</span> and on <span class="math inline">\(\ket{1}\)</span> respectively.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qPlus::</span><span class="dt">Qubit</span>
qPlus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>, <span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">qMinus::</span><span class="dt">Qubit</span> 
qMinus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>, <span class="fu">-</span><span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>For now, we have defined a Qubit type and we can create any qubit. We also define some functions that will create the most used qubits. In future articles we will define a Gate type and we will also implement some operations.</p>
<p>Based on my experience that I have on this topic after doing some research and implementing from scratch a library in Java I was surprised when I saw how fast I can implement this code in Haskell. It was quite simple and it took less time.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>

</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>
