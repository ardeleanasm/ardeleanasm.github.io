<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laziness leads to progress - Quantum Computing in Haskell - I part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Laziness leads to progress!</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Quantum Computing in Haskell - I part</h1>
            <article>
    <section class="header">
        Posted on July 26, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="long-story-made-short">Long story made short</h2>
<p>1 year ago I started studying the topics of Quantum Computing and Quantum Algorithms and I was fascinated. Is interresting and, like Niels Bohr said, “Anyone who is not shocked by quantum theory has not understood it.”</p>
<p>As doing my research I found quite interesting to post some small articles on these topics, some articles on CodeProject (<a href="https://www.codeproject.com/Articles/1130092/Java-based-Quantum-Computing-library">Java based Quantum Computing Library</a> and <a href="https://www.codeproject.com/Articles/1131573/Grovers-Search-Algorithm-explained">Grover’s Search Algorithm Explained</a>) and one on my website about <a href="2016-08-17-deutschs-algorithm.html">Deutsch’s algorithm</a>. For those articles I used a Java library that I created myself with the help of some of my colleagues. Now, after a year and after playing a little with Haskell, I found quite interesting to review the topic and to start posting a series of small articles about Quantum Computing.</p>
<h2 id="introduction">Introduction</h2>
<p>I’ll start by talking a little about the difference between a quantum computer and a traditional one. A lot of information about how a quantum computer works can be found in online courses, research papers and books. It’s not the scope of this post to explain in details how it works, just to present some basic differences.</p>
<p>As someone can expect, a quantum computer use the quantum mechanical effects, such as superposition, to carry out computations. We already know that in a traditional computer, the <strong>bit</strong> is the basic unit and it can be 0 or 1. The value is defined by a voltage level, in TTL technology, ideally, a 1 value is represented by 5.00 volts while a 0 value is represented by 0.00 volts. For a quantum computer, there are some differences. For example, the basic unit is the <strong>qubit</strong> (quantum bit) and can, at one time, represent value 0 and 1, by exploiting superposition. A qubit is defined by the equation presented below:</p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math inline">\(\ket{v}=\alpha\ket{0}+\beta\ket{1}\)</span></p>
<p>Before diving deeper into the subject, we will firstly review some mathematical aspects of the topic.</p>
<h2 id="complex-numbers">Complex Numbers</h2>
<p>Since probability amplitudes of a qubit are complex numbers I prefer to start with a very short introduction in the mathematics of complex numbers.</p>
<p>A complex number q is defined as <span class="math inline">\(q=a+bi\)</span> where a and b <span class="math inline">\(\in \mathcal{R}\)</span> and <span class="math inline">\(i=\sqrt{-1}\)</span> is the imaginary basis unit.</p>
<p>We can see that <strong>a</strong> is the real component of a complex number and <strong>bi</strong> is the imaginary one. We can obtain the complex conjugate by simply negating the sign of the imaginary component <span class="math inline">\(\overline{q}=a-bi\)</span>.</p>
<p>Some basic formulas that we will use during this series of articles will be addition, multiplication, and modulus.</p>
<p>Let’s consider 2 complex numbers x and y defined like:</p>
<p><span class="math display">\[x=a+bi\]</span></p>
<p>and</p>
<p><span class="math display">\[y=c+di\]</span></p>
<p>The addition of these 2 complex numbers is defined by:</p>
<p><span class="math display">\[z=x+y=a+bi+c+di=a+c+i(b+d)\]</span></p>
<p>while multiplication is defined by:</p>
<p><span class="math display">\[z=x*y=(a+bi)(c+di)=ac-bd+i(ad+cb)\]</span></p>
<p>The third operation, the modulus of the complex number x is defined by:</p>
<p><span class="math display">\[|x|=\sqrt{a^2+b^2}\]</span></p>
<h2 id="vectors">Vectors</h2>
<p>While Complex Numbers are used to represent the probability amplitudes of a qubit, vectors and linear algebra helps us to represent qubits, so I decided that it’ll be usefull to present some notations and operations before starting to write code.</p>
<p>Basically, the state of a qubit is a unit vector in a 2-dimensional complex vector space <span class="math inline">\(\mathcal{C}^2\)</span>.</p>
<p>The vector <span class="math display">\[\begin{bmatrix}\alpha\\ \beta\end{bmatrix}\]</span> can be written as</p>
<p><span class="math display">\[\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where</p>
<p><span class="math display">\[\ket{0}=\begin{bmatrix}1\\0\end{bmatrix}\]</span></p>
<p>and</p>
<p><span class="math display">\[\ket{1}=\begin{bmatrix}0\\1\end{bmatrix}\]</span></p>
<p>In the above example I used the <strong>bra-ket</strong> notation, the notation of a column vector is called <strong>ket</strong> while the notation of a row vector is called <strong>bra</strong>. Next, I will define 3 basic operations that will be used heavily in the examples from the next articles on this topic, the inner product, outer product and tensor product.</p>
<p>The inner product, <span class="math inline">\(\bra{v}\ket{v}\)</span> is the product between the bra and the ket vectors:</p>
<p><span class="math display">\[\bra{v}\ket{v}=\begin{pmatrix}{c_1}^* &amp; {c_2}^* \end{pmatrix}\begin{pmatrix}{c_1} \\ {c_2} \end{pmatrix}={c_1}^*{c_1}+{c_2}^*{c_2}={|c_1|}^2+{|c_2|}^2\]</span></p>
<p>Outer product is <strong>ket-bra</strong> and is given by:</p>
<p><span class="math display">\[\ket{v}\bra{v}=\begin{pmatrix}c_1 \\ c_2 \end{pmatrix}\begin{pmatrix}{c_1}^* &amp; {c_2}^*\end{pmatrix}=\begin{pmatrix} c_1{c_1}^* &amp; c_1{c_2}^* \\ c_2{c_1}^* &amp; c_2{c_2}^* \end{pmatrix}\]</span></p>
<p>Lastly, if we consider <span class="math display">\[\ket{v}=\begin{pmatrix}{c_1} \\ {c_2} \end{pmatrix}\]</span> and <span class="math display">\[\ket{x}=\begin{pmatrix}{c_3} \\ {c_4} \end{pmatrix}\]</span> we can define the tensor product as:</p>
<p><span class="math display">\[\ket{v}\otimes\ket{x}=\ket{vx}=\begin{pmatrix}{c_1}{c_3} \\ {c_2}{c_3} \\ {c_1}{c_4} \\ {c_2}{c_4} \end{pmatrix}\]</span></p>
<h2 id="qubits-and-gates">Qubits and Gates</h2>
<p>Quantum mechanics tells that any such system can exist in a superposition of states and as we saw in the second chapter, the state of a qubit is described by</p>
<p><span class="math display">\[\ket{v}=\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are complex number that satisfy the relation</p>
<p><span class="math display">\[{|\alpha|}^2+{|\beta|}^2=1\]</span></p>
<p>We know that on a classic computer gate operations such as <strong>AND</strong>, <strong>OR</strong>,<strong>XOR</strong> constitute the core of data manipulation. On a quantum computer similar operations are possible on qubits by using quantum gates. The gate operations are exactly all unitary linear operations.</p>
<p>For example, the Hadamard transformation is defined as:</p>
<p><span class="math display">\[\alpha\ket{0}+\beta\ket{1}\rightarrow\frac{\alpha+\beta}{\sqrt{2}}\ket{0}+\frac{\alpha-\beta}{\sqrt{2}}\ket{1}\]</span></p>
<p>Knowing that <span class="math display">\[\ket{0}=\begin{bmatrix}{1} \\ {0} \end{bmatrix}\]</span> and <span class="math display">\[\ket{1}=\begin{bmatrix}{0} \\ {1} \end{bmatrix}\]</span> then we can represent the transformation as the matrix:</p>
<p><span class="math display">\[\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}\]</span></p>
<p>A Hadamard gate creates a superposition state, often beginning and ending a quantum computation to initiate data processing and to collect data, respectively.</p>
<p>A set of useful 1-qubit gates are the Pauli Gates, the X gate, Y gate and Z gate.</p>
<p><span class="math display">\[X\ket{0}=\ket{1} and X\ket{1}=\ket{1}; X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p>
<p><span class="math display">\[Y\ket{0}=i\ket{1} and Y\ket{1}=-i\ket{0}; Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}\]</span></p>
<p><span class="math display">\[Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}; Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\]</span></p>
<p>Two more gates that we will use in our examples are the Controlled-Not and Controlled Phase Shift and they are defined by the following matrices:</p>
<p><span class="math display">\[Controlled Phase Shift=\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1\end{pmatrix}\]</span></p>
<p><span class="math display">\[Controlled Not=\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}\]</span></p>
<p>In the next article we will write some code that implements some basic operations.</p>
    </section>
</article>
        </main>

        <footer>
            <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>


            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
