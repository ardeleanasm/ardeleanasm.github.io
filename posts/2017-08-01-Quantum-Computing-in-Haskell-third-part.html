<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - Quantum Computing in Haskell - III part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Quantum Computing in Haskell - III part</h1>
            <!--<article>
    <section class="header">
        Posted on August  1, 2017
        
    </section>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell/">Quantum Computing in Haskell - I part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-second-part/">Quantum Computing in Haskell - II part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-third-part/">Quantum Computing in Haskell - III part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-fourth-part/">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the second part of this series I talked about the Haskell implementation of Qubits. There are two more articles about the library and after that I will start posting about algorithms. In this article we will define some Quantum Gates that we will use in our algorithms, even if in the first article I wrote a little about this topic and I presented some matrices.</p>
<h2 id="background">Background</h2>
<p>As we already know computers are built using logic gates and in a similar way quantum computation also use logic gates that can be designed by considering unitary transformation of the qubits. In conclusion, we can construct infinitely many quantum logic gates with the constraint that they must be reversible.</p>
<p>In the first article from this series I already presented some gates but we didn’t see their symbol or truth table.</p>
<h3 id="qubit-gates">1 qubit gates</h3>
<h4 id="pauli-x-gate-or-not-gate">Pauli X-Gate or NOT gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/xgate.png" title="Pauli XGate" alt="X-Gate Symbol" />
<p class="caption">X-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math display">\[X\ket{0}=\ket{1}, X\ket{1}=\ket{0}\]</span></p>
<h4 id="pauli-y-gate">Pauli Y-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/ygate.png" title="Pauli YGate" alt="Y-Gate Symbol" />
<p class="caption">Y-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Y\ket{0}=i\ket{1}, Y\ket{1}=-i\ket{0}\]</span></p>
<h4 id="pauli-z-gate">Pauli Z-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/zgate.png" title="Pauli ZGate" alt="Z-Gate Symbol" />
<p class="caption">Z-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}\]</span></p>
<h4 id="hadamard-gate">Hadamard Gate:</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/hgate.png" title="Hadamard Gate" alt="H-Gate Symbol" />
<p class="caption">H-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[H=\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[H\ket{0}=\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}), H\ket{1}=\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})\]</span></p>
<h3 id="controlled-quantum-gates">Controlled Quantum Gates</h3>
<p>Controlled Quantum Gates are useful for implementing <strong>IF-THEN-ELSE</strong> type operations. In this article we will only present <strong>CNOT</strong>.</p>
<h4 id="controlled-not-cnot">Controlled-NOT (CNOT)</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/cnotgate.png" title="Controlled-NOT" alt="CNOT-Gate Symbol" />
<p class="caption">CNOT-Gate Symbol</p>
</div>
<p><em>Truth Table:</em></p>
<table>
<thead>
<tr class="header">
<th align="center">x</th>
<th align="center">y</th>
<th align="center">x <span class="math inline">\((x\oplus y)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0 0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0 1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1 1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1 0</td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>
<p>Having the background now, let’s start implementing those gates in Haskell. First, let’s define a new data named <strong>Gate</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Gate</span><span class="fu">=</span>
  <span class="dt">Gate</span> {
<span class="ot">          gateMatrix::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) 
        } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Our data <strong>Gate</strong> has a constructor <strong>Gate</strong> with one parameter, <strong>gateMatrix</strong>, of type ** complex matrx<strong>, <code>Matrix C</code>. Let’s see the code in </strong>GHCI**:</p>
<p><code>ghci&gt;:t Gate Gate :: Matrix C -&gt; Gate ghci&gt;let g= Gate ((2&gt;&lt;2) [1,0,0,-1]::Matrix C) ghci&gt;g Gate {gateMatrix = (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]} ghci&gt;&gt;gateMatrix g (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]</code></p>
<p>In the above example we created a Pauli Z-Gate. We will proceed like for Qubit and we will define some functions that will return a Gate. We will implement the Pauli X-Gate, Y-Gate, Z-Gate, Hadamard Gate, CNOT-Gate, and Controlled Phase Shift Gate ( we will need in Grover’s Algorithm).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xGate::</span><span class="dt">Gate</span>
xGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>)[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">yGate::</span><span class="dt">Gate</span>
yGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="fl">0.0</span>,<span class="fl">0.0</span><span class="fu">:+</span>(<span class="fu">-</span><span class="fl">1.0</span>),<span class="fl">0.0</span><span class="fu">:+</span><span class="fl">1.0</span>,<span class="fl">0.0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">zGate::</span><span class="dt">Gate</span>
zGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">hGate::</span><span class="dt">Gate</span>
hGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,(<span class="fu">-</span><span class="dv">1</span>)<span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cNotGate::</span><span class="dt">Gate</span>
cNotGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cPhaseShifGate::</span><span class="dt">Gate</span>
cPhaseShifGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<p>Now, in GHCI, if we call, for example <code>zGate</code> we will see that the output is the same with the one from the previous example:</p>
<pre><code>ghci&gt;zGate
Gate {gateMatrix = (2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]}
ghci&gt;:t zGate
zGate :: Gate</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>In this article we implemented some 1-qubit Gates and some Controlled-Gate. In next articles we will define some functions to apply those gate on qubits and also to create gates, starting from 1-qubit ones, that apply on multiple qubits. New ideas, features, issues are welcomed and I encourage every reader to submit them on Github or ask questions using Disquss.</p>
    </section>
</article>
-->

<article>
    <section class="header">
        Posted on August  1, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell/">Quantum Computing in Haskell - I part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-second-part/">Quantum Computing in Haskell - II part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-third-part/">Quantum Computing in Haskell - III part</a></li>
<li><a href="https://ardeleanasm.github.io/Quantum-Computing-in-Haskell-fourth-part/">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the second part of this series I talked about the Haskell implementation of Qubits. There are two more articles about the library and after that I will start posting about algorithms. In this article we will define some Quantum Gates that we will use in our algorithms, even if in the first article I wrote a little about this topic and I presented some matrices.</p>
<h2 id="background">Background</h2>
<p>As we already know computers are built using logic gates and in a similar way quantum computation also use logic gates that can be designed by considering unitary transformation of the qubits. In conclusion, we can construct infinitely many quantum logic gates with the constraint that they must be reversible.</p>
<p>In the first article from this series I already presented some gates but we didn’t see their symbol or truth table.</p>
<h3 id="qubit-gates">1 qubit gates</h3>
<h4 id="pauli-x-gate-or-not-gate">Pauli X-Gate or NOT gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/xgate.png" title="Pauli XGate" alt="X-Gate Symbol" />
<p class="caption">X-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math display">\[X\ket{0}=\ket{1}, X\ket{1}=\ket{0}\]</span></p>
<h4 id="pauli-y-gate">Pauli Y-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/ygate.png" title="Pauli YGate" alt="Y-Gate Symbol" />
<p class="caption">Y-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Y\ket{0}=i\ket{1}, Y\ket{1}=-i\ket{0}\]</span></p>
<h4 id="pauli-z-gate">Pauli Z-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/zgate.png" title="Pauli ZGate" alt="Z-Gate Symbol" />
<p class="caption">Z-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}\]</span></p>
<h4 id="hadamard-gate">Hadamard Gate:</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/hgate.png" title="Hadamard Gate" alt="H-Gate Symbol" />
<p class="caption">H-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[H=\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[H\ket{0}=\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}), H\ket{1}=\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})\]</span></p>
<h3 id="controlled-quantum-gates">Controlled Quantum Gates</h3>
<p>Controlled Quantum Gates are useful for implementing <strong>IF-THEN-ELSE</strong> type operations. In this article we will only present <strong>CNOT</strong>.</p>
<h4 id="controlled-not-cnot">Controlled-NOT (CNOT)</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="https://ardeleanasm.github.io/resources/quantum_serie/cnotgate.png" title="Controlled-NOT" alt="CNOT-Gate Symbol" />
<p class="caption">CNOT-Gate Symbol</p>
</div>
<p><em>Truth Table:</em></p>
<table>
<thead>
<tr class="header">
<th align="center">x</th>
<th align="center">y</th>
<th align="center">x <span class="math inline">\((x\oplus y)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0 0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0 1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1 1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1 0</td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>
<p>Having the background now, let’s start implementing those gates in Haskell. First, let’s define a new data named <strong>Gate</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Gate</span><span class="fu">=</span>
  <span class="dt">Gate</span> {
<span class="ot">          gateMatrix::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) 
        } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Our data <strong>Gate</strong> has a constructor <strong>Gate</strong> with one parameter, <strong>gateMatrix</strong>, of type ** complex matrx<strong>, <code>Matrix C</code>. Let’s see the code in </strong>GHCI**:</p>
<p><code>ghci&gt;:t Gate Gate :: Matrix C -&gt; Gate ghci&gt;let g= Gate ((2&gt;&lt;2) [1,0,0,-1]::Matrix C) ghci&gt;g Gate {gateMatrix = (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]} ghci&gt;&gt;gateMatrix g (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]</code></p>
<p>In the above example we created a Pauli Z-Gate. We will proceed like for Qubit and we will define some functions that will return a Gate. We will implement the Pauli X-Gate, Y-Gate, Z-Gate, Hadamard Gate, CNOT-Gate, and Controlled Phase Shift Gate ( we will need in Grover’s Algorithm).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xGate::</span><span class="dt">Gate</span>
xGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>)[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">yGate::</span><span class="dt">Gate</span>
yGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="fl">0.0</span>,<span class="fl">0.0</span><span class="fu">:+</span>(<span class="fu">-</span><span class="fl">1.0</span>),<span class="fl">0.0</span><span class="fu">:+</span><span class="fl">1.0</span>,<span class="fl">0.0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">zGate::</span><span class="dt">Gate</span>
zGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">hGate::</span><span class="dt">Gate</span>
hGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,(<span class="fu">-</span><span class="dv">1</span>)<span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cNotGate::</span><span class="dt">Gate</span>
cNotGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cPhaseShifGate::</span><span class="dt">Gate</span>
cPhaseShifGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<p>Now, in GHCI, if we call, for example <code>zGate</code> we will see that the output is the same with the one from the previous example:</p>
<pre><code>ghci&gt;zGate
Gate {gateMatrix = (2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]}
ghci&gt;:t zGate
zGate :: Gate</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>In this article we implemented some 1-qubit Gates and some Controlled-Gate. In next articles we will define some functions to apply those gate on qubits and also to create gates, starting from 1-qubit ones, that apply on multiple qubits. New ideas, features, issues are welcomed and I encourage every reader to submit them on Github or ask questions using Disquss.</p>
    </section>
</article>
        </main>

        <footer>
            <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/feed.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>


            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
