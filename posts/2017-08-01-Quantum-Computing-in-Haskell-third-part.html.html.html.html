<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Quantum Computing in Haskell - III part</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/blogstyle.css" />
</head>
<body>
<div class="header"> <a href="../blog.html">&larr; Posts</a> </div>
<header>
<h1 class="title">Quantum Computing in Haskell - III part</h1>
</header>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<h2 id="articles">Articles</h2>
<ul>
<li><a href="./2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="./2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="./2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="./2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the second part of this series I talked about the Haskell implementation of Qubits. There are two more articles about the library and after that I will start posting about algorithms. In this article we will define some Quantum Gates that we will use in our algorithms, even if in the first article I wrote a little about this topic and I presented some matrices.</p>
<h2 id="background">Background</h2>
<p>As we already know computers are built using logic gates and in a similar way quantum computation also use logic gates that can be designed by considering unitary transformation of the qubits. In conclusion, we can construct infinitely many quantum logic gates with the constraint that they must be reversible.</p>
<p>In the first article from this series I already presented some gates but we didn’t see their symbol or truth table.</p>
<h3 id="qubit-gates">1 qubit gates</h3>
<h4 id="pauli-x-gate-or-not-gate">Pauli X-Gate or NOT gate</h4>
<p><em>Symbol:</em></p>
<figure>
<img src="../img/blog/quantum_serie/xgate.png" title="Pauli XGate" alt="X-Gate Symbol" /><figcaption>X-Gate Symbol</figcaption>
</figure>
<p><em>Matrix:</em></p>
<p><br />
<span class="math display">$$X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}$$</span><br />
</p>
<p><em>Transformation:</em></p>
<p><br />
<span class="math display"></span><br />
<br />
<span class="math display"></span><br />
<br />
<span class="math display">$$X\ket{0}=\ket{1}, X\ket{1}=\ket{0}$$</span><br />
</p>
<h4 id="pauli-y-gate">Pauli Y-Gate</h4>
<p><em>Symbol:</em></p>
<figure>
<img src="../img/blog/quantum_serie/ygate.png" title="Pauli YGate" alt="Y-Gate Symbol" /><figcaption>Y-Gate Symbol</figcaption>
</figure>
<p><em>Matrix:</em></p>
<p><br />
<span class="math display">$$Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}$$</span><br />
</p>
<p><em>Transformation:</em></p>
<p><br />
<span class="math display">$$Y\ket{0}=i\ket{1}, Y\ket{1}=-i\ket{0}$$</span><br />
</p>
<h4 id="pauli-z-gate">Pauli Z-Gate</h4>
<p><em>Symbol:</em></p>
<figure>
<img src="../img/blog/quantum_serie/zgate.png" title="Pauli ZGate" alt="Z-Gate Symbol" /><figcaption>Z-Gate Symbol</figcaption>
</figure>
<p><em>Matrix:</em></p>
<p><br />
<span class="math display">$$Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}$$</span><br />
</p>
<p><em>Transformation:</em></p>
<p><br />
<span class="math display">$$Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}$$</span><br />
</p>
<h4 id="hadamard-gate">Hadamard Gate:</h4>
<p><em>Symbol:</em></p>
<figure>
<img src="../img/blog/quantum_serie/hgate.png" title="Hadamard Gate" alt="H-Gate Symbol" /><figcaption>H-Gate Symbol</figcaption>
</figure>
<p><em>Matrix:</em></p>
<p><br />
<span class="math display">$$H=\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}$$</span><br />
</p>
<p><em>Transformation:</em></p>
<p><br />
<span class="math display">$$H\ket{0}=\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}), H\ket{1}=\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})$$</span><br />
</p>
<h3 id="controlled-quantum-gates">Controlled Quantum Gates</h3>
<p>Controlled Quantum Gates are useful for implementing <strong>IF-THEN-ELSE</strong> type operations. In this article we will only present <strong>CNOT</strong>.</p>
<h4 id="controlled-not-cnot">Controlled-NOT (CNOT)</h4>
<p><em>Symbol:</em></p>
<figure>
<img src="../img/blog/quantum_serie/cnotgate.png" title="Controlled-NOT" alt="CNOT-Gate Symbol" /><figcaption>CNOT-Gate Symbol</figcaption>
</figure>
<p><em>Truth Table:</em></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">x</th>
<th style="text-align: center;">y</th>
<th style="text-align: center;">x<br />
<span class="math display">(<em>x</em> ⊕ <em>y</em>)</span><br />
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0 0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0 1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1 1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1 0</td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>
<p>Having the background now, let’s start implementing those gates in Haskell. First, let’s define a new data named <strong>Gate</strong>.</p>
<div id="cb1" class="sourceCode">
<div id="cb1" class="sourceCode">
<div id="cb1" class="sourceCode">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Gate</span><span class="fu">=</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">Gate</span> {</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">          gateMatrix::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) </a>
<a class="sourceLine" id="cb1-4" title="4">        } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</a></code></pre></div>
</div>
</div>
</div>
<p>Our data <strong>Gate</strong> has a constructor <strong>Gate</strong> with one parameter, <strong>gateMatrix</strong>, of type ** complex matrx<strong>, <code>Matrix C</code>. Let’s see the code in</strong> GHCI**:</p>
<pre><code>ghci&gt;:t Gate
Gate :: Matrix C -&gt; Gate
ghci&gt;let g= Gate ((2&gt;&lt;2) [1,0,0,-1]::Matrix C)
ghci&gt;g
Gate {gateMatrix = (2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]}
ghci&gt;&gt;gateMatrix g
(2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]</code></pre>
<p>In the above example we created a Pauli Z-Gate. We will proceed like for Qubit and we will define some functions that will return a Gate. We will implement the Pauli X-Gate, Y-Gate, Z-Gate, Hadamard Gate, CNOT-Gate, and Controlled Phase Shift Gate ( we will need in Grover’s Algorithm).</p>
<div id="cb3" class="sourceCode">
<div id="cb3" class="sourceCode">
<div id="cb3" class="sourceCode">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">xGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-2" title="2">xGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>)[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">yGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-5" title="5">yGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="fl">0.0</span>,<span class="fl">0.0</span><span class="fu">:+</span>(<span class="fu">-</span><span class="fl">1.0</span>),<span class="fl">0.0</span><span class="fu">:+</span><span class="fl">1.0</span>,<span class="fl">0.0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="ot">zGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-8" title="8">zGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="ot">hGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-11" title="11">hGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>,(<span class="fu">-</span><span class="dv">1</span>)<span class="fu">/sqrt</span> <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb3-12" title="12"></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="ot">cNotGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-14" title="14">cNotGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb3-15" title="15"></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="ot">cPhaseShifGate::</span><span class="dt">Gate</span></a>
<a class="sourceLine" id="cb3-17" title="17">cPhaseShifGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a></code></pre></div>
</div>
</div>
</div>
<p>Now, in GHCI, if we call, for example <code>zGate</code> we will see that the output is the same with the one from the previous example:</p>
<pre><code>ghci&gt;zGate
Gate {gateMatrix = (2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]}
ghci&gt;:t zGate
zGate :: Gate</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>In this article we implemented some 1-qubit Gates and some Controlled-Gate. In next articles we will define some functions to apply those gate on qubits and also to create gates, starting from 1-qubit ones, that apply on multiple qubits. New ideas, features, issues are welcomed and I encourage every reader to submit them on Github or ask questions using Disquss.</p>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header"> <a href="../blog.html">&larr; Posts</a> </div>
</body>
</html>
