<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Quantum Computing in Haskell - II part</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/blogstyle.css" />
</head>
<body>
<div class="header"> <a href="../blog.html">&larr; Posts</a> </div>
<header>
<h1 class="title">Quantum Computing in Haskell - II part</h1>
</header>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<h2 id="articles">Articles</h2>
<ul>
<li><a href="./2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="./2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="./2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="./2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the first article from this series I presented some basic math and I suggest reading that article first if someone is not familiar with the topic of Quantum Computing. In this article, the second from the series I will present the implementation in Haskell. The plan is that after a few articles in which I will present the data types, modules, functions, we will implement some Quantum algorithms like Deutsch’s Algorithm, Grover’s Algorithm, Deutsch-Josza’s Algorithm and maybe Shor’s algorithm.</p>
<h2 id="background">Background</h2>
<p>We saw in the previous article that the state of a qubit can be described by</p>
<p><br />
<span class="math display"></span><br />
<br />
<span class="math display"></span><br />
<br />
<span class="math display">$$\ket{v}=\alpha\ket{0}+\beta\ket{1}$$</span><br />
</p>
<p>where</p>
<p><br />
<span class="math display">|<em>α</em>|<sup>2</sup> + |<em>β</em>|<sup>2</sup> = 1</span><br />
</p>
<p>and</p>
<p><br />
<span class="math display">$$\ket{0}=\begin{bmatrix} 1 \\ 0\end{bmatrix}$$</span><br />
<br />
<span class="math display">$$\ket{1}=\begin{bmatrix} 0 \\ 1\end{bmatrix}$$</span><br />
</p>
<p>It’s clearly, from the above equations, that we have to implement a Qubit type and the qubits<br />
<span class="math display">$$\ket{0}$$</span><br />
and<br />
<span class="math display">$$\ket{1}$$</span><br />
.</p>
<h2 id="implementation">Implementation</h2>
<p>For the implementation in Haskell I chose to use <a href="https://hackage.haskell.org/package/hmatrix">hmatrix</a> library because we will have to work with matrices and vectors and by using this library we won’t have to implement new types and functions that performs the needed operations.</p>
<p>Anyway, a simple solution that don’t use hmatrix is to define our own <strong>matrix</strong> and <strong>vector</strong> types like</p>
<div id="cb1" class="sourceCode">
<div id="cb1" class="sourceCode">
<div id="cb1" class="sourceCode">
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">type</span> <span class="dt">Vector</span> a<span class="fu">=</span>[a]</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">type</span> <span class="dt">Matrix</span> a<span class="fu">=</span>[<span class="dt">Vector</span> a]</a></code></pre></div>
</div>
</div>
</div>
<p>and also some functions that will create our complex vectors and matrices</p>
<div id="cb2" class="sourceCode">
<div id="cb2" class="sourceCode">
<div id="cb2" class="sourceCode">
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">complexVector::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Vector</span> a<span class="ot">-&gt;</span><span class="dt">Vector</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">complexVector<span class="fu">=map</span>(\i<span class="ot">-&gt;</span><span class="fu">realToFrac</span> i<span class="fu">:+</span><span class="fl">0.0</span>)</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">complexMatrix::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Matrix</span> a<span class="ot">-&gt;</span><span class="dt">Matrix</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">complexMatrix<span class="fu">=map</span> complexVector</a></code></pre></div>
</div>
</div>
</div>
<p>Since I don’t think that is a feasible approach I won’t discuss the above code. Is nice to know that we can implement it without using hmatrix, is another approach, even the first version of code from repository was implemented this way but it’s a lot of work. I won’t reinvent the wheel, at least for now! :)</p>
<p>Ok, first of all let’s define a new data named <strong>Qubit</strong>.</p>
<div id="cb3" class="sourceCode">
<div id="cb3" class="sourceCode">
<div id="cb3" class="sourceCode">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">Qubit</span><span class="fu">=</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="dt">Qubit</span> {</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">            qubitState::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) </a>
<a class="sourceLine" id="cb3-4" title="4">          } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</a></code></pre></div>
</div>
</div>
</div>
<p>Our data type has a constructor <strong>Qubit</strong> with one parameter, <strong>qubitState</strong>, of type <strong>complex matrix</strong>, <code>Matrix C</code>. If we load the above code in <strong>GHCI</strong> we can check the new type that we defined:</p>
<pre><code>ghci&gt; :t Qubit
Qubit :: Matrix C -&gt; Qubit</code></pre>
<p>We can see that Qubit is the data type and the constructors accepts an argument of type <em>Matrix C</em> and returns a <em>Qubit</em>. Ok, now let’s try to create a Qubit.</p>
<pre><code>ghci&gt;let q=Qubit ((2&gt;&lt;1)[1,0]::Matrix C)
ghci&gt;q
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;qubitState q
(2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]</code></pre>
<p>Basically, in the above example we created the<br />
<span class="math display">$$\ket{0}$$</span><br />
. Since in our future examples we will use it a lot alongside<br />
<span class="math display">$$\ket{1}$$</span><br />
we should define some functions that will return them.</p>
<div id="cb6" class="sourceCode">
<div id="cb6" class="sourceCode">
<div id="cb6" class="sourceCode">
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">qZero::</span><span class="dt">Qubit</span></a>
<a class="sourceLine" id="cb6-2" title="2">qZero<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>)[<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">qOne::</span><span class="dt">Qubit</span></a>
<a class="sourceLine" id="cb6-5" title="5">qOne<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a></code></pre></div>
</div>
</div>
</div>
<p>One question that might arise after seeing the code is “Ok, why is Matrix type used instead of Vector?” The answer is quite simple, because we will have to implement, in the next articles, some operations with qubits and gates and is more simple to have the same type for both. Now, if we fire up GHCI and type:</p>
<pre><code>ghci&gt;&gt;qZero
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;&gt;qOne
Qubit {qubitState = (2&gt;&lt;1)
 [ 0.0 :+ 0.0
 , 1.0 :+ 0.0 ]}</code></pre>
<p>we see that we have two functions that returns our needed qubits.</p>
<p>After the experience that I have with <a href="https://github.com/ardeleanasm/quantum_computing">Java Library for Quantum Computing</a> I think that is useful to also define two more qubits,<br />
<span class="math display">$$\ket{+}$$</span><br />
and<br />
<span class="math display">$$\ket{-}$$</span><br />
. Those qubits can be simply obtained by simply applying the Hadamard Gate on<br />
<span class="math display">$$\ket{0}$$</span><br />
and on<br />
<span class="math display">$$\ket{1}$$</span><br />
respectively.</p>
<div id="cb8" class="sourceCode">
<div id="cb8" class="sourceCode">
<div id="cb8" class="sourceCode">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">qPlus::</span><span class="dt">Qubit</span></a>
<a class="sourceLine" id="cb8-2" title="2">qPlus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>, <span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">qMinus::</span><span class="dt">Qubit</span> </a>
<a class="sourceLine" id="cb8-5" title="5">qMinus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>, <span class="fu">-</span><span class="dv">1</span><span class="fu">/sqrt</span> <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</a></code></pre></div>
</div>
</div>
</div>
<h2 id="conclusions">Conclusions</h2>
<p>For now, we have defined a Qubit type and we can create any qubit. We also define some functions that will create the most used qubits. In future articles we will define a Gate type and we will also implement some operations.</p>
<p>Based on my experience that I have on this topic after doing some research and implementing from scratch a library in Java I was surprised when I saw how fast I can implement this code in Haskell. It was quite simple and it took less time.</p>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header">
<a href="../blog.html">← Posts</a>
</div>
<div class="header"> <a href="../blog.html">&larr; Posts</a> </div>
</body>
</html>
