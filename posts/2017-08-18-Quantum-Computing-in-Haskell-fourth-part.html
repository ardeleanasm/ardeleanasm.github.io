<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Quantum Computing in Haskell - IV part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-54128414-2"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'UA-54128414-2');
      </script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">Home</a>
                <a href="../blog.html" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">Blog</a>
                <a href="../archive.html" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        <h2>Quantum Computing in Haskell - IV part</h2>
        Posted on August 18, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous articles, first three parts, I presented some haskell code to implement basic operators for simulating Quantum Algorithms. The full source code can be downloaded from <a href="https://github.com/ardeleanasm/qchas">Github Repository</a>. The library was also published on <a href="https://hackage.haskell.org/package/qchas">Hackage</a> and also on <a href="https://www.stackage.org/nightly-2017-08-17/package/qchas-1.0.1.0">Stackage</a> and is available with 2 versions, 1.0.0 and 1.0.1.0. Starting from version 1.0.1.0 the <strong>Utils</strong> module was removed and also, a new module for performing measurements was added. These articles will be also used as documentation/ wiki for the library. <!--more--></p>
<p>In this fourth part we will start to present some Quantum Algorithms and we will start with one of the simplest ones, Deutsch’s algorithm. In the next articles from the serie we will talk about Deutsch-Jozsa’s algorithm, Grover’s and Shor.</p>
<h2 id="background">Background</h2>
<p>As I said in a previous article when I implemented this algorithm in Java, the problem that Deutsch’s algorithm solves is not an important one in Computer Science but it’s a good example to see the power of quantum computers, being solved by a quantum computer faster than by a traditional one, although not exponentially faster.</p>
<p>So, let’s suppose that we have a function f with 1-bit input and 1-bit output. There are four possible functions, two of them are constant and two are balanced, as we can see in the table below.</p>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(f_{1}(0)=0, f_{1}(1)=0\)</span></td>
<td align="center">constant</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(f_{2}(0)=1, f_{2}(1)=1\)</span></td>
<td align="center">constant</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(f_{3}(0)=0, f_{3}(1)=1\)</span></td>
<td align="center">balanced</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(f_{4}(0)=1, f_{4}(1)=0\)</span></td>
<td align="center">balanced</td>
</tr>
</tbody>
</table>
<p>The goal is to determine whether the function is constant or not. Let’s say that we implement such a function on a classic computer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main::</span><span class="dt">IO</span> ()
main<span class="fu">=</span><span class="kw">do</span>
  print <span class="fu">$</span> testFunction f1
  print <span class="fu">$</span> testFunction f2
  print <span class="fu">$</span> testFunction f3
  print <span class="fu">$</span> testFunction f4

<span class="ot">f1::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f1 val<span class="fu">=</span><span class="dv">0</span>

<span class="ot">f2::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f2 val<span class="fu">=</span><span class="dv">1</span>

<span class="ot">f3::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f3 val<span class="fu">=</span>val

<span class="ot">f4::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f4 val
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">1</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">testFunction::</span>(<span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>)<span class="ot">-&gt;</span><span class="dt">String</span>
testFunction f
  <span class="fu">|</span>f <span class="dv">0</span> <span class="fu">==</span> f <span class="dv">1</span><span class="fu">=</span> <span class="st">&quot;Constant&quot;</span>
  <span class="fu">|</span>otherwise<span class="fu">=</span> <span class="st">&quot;Balanced&quot;</span></code></pre></div>
<p>and the output will be:</p>
<pre><code>&quot;Constant&quot;
&quot;Constant&quot;
&quot;Balanced&quot;
&quot;Balanced&quot;</code></pre>
<p>It can be easily seen that to check if a function is constant or balanced on a classical computer we need two calls to that function, basically we evaluate the function twice. We will see next that by using Deutsch’s algorithm the problem can be solved by evaluating the function only once.</p>
<div class="figure">
<img src="../images/deutsch_quantum_circuits.png" alt="The quantum circuit of Deutsch’s algorithm1" />
<p class="caption">The quantum circuit of Deutsch’s algorithm<a href="https://github.com/ardeleanasm/qchas">1</a></p>
</div>
<p>The quantum circuit that we will have to implement can be seen in the picture above and basically we will have to:</p>
<ul>
<li>Apply <strong>X-Gate</strong> on the second qubit</li>
<li>Apply <span class="math inline">\(H^2\)</span> gate, the Kronecker product between two <strong>Hadamard</strong> Gates</li>
<li>Apply the gate ( or “oracle”) <span class="math inline">\(U_f\)</span></li>
<li>Apply Hadamard Gate again on the first qubit</li>
<li>Measure the circuit</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>First of all, let’s define the unitary transformations for all four functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--f(0)=0 and f(1)=0</span>
<span class="ot">f1::</span><span class="dt">Gate</span>
f1<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=1</span>
<span class="ot">f2::</span><span class="dt">Gate</span>
f2<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=0 and f(1)=1</span>
<span class="ot">f3::</span><span class="dt">Gate</span>
f3<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=0</span>
<span class="ot">f4::</span><span class="dt">Gate</span>
f4<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)                </code></pre></div>
<p>The next step is to define a function that will test all the four functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testDeutschsAlgorithm::</span><span class="dt">IO</span>()
testDeutschsAlgorithm<span class="fu">=</span>mapM_ deutsch [f1,f2,f3,f4]</code></pre></div>
<p>Now, let’s implement the algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">deutsch::</span><span class="dt">Gate</span><span class="ot">-&gt;</span><span class="dt">IO</span>()
deutsch oracle<span class="fu">=</span><span class="kw">do</span> <span class="kw">let</span> (result<span class="fu">:</span>_)<span class="fu">=</span>measure circuit
                  <span class="kw">case</span> result <span class="kw">of</span>
                    <span class="ch">'0'</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is constant&quot;</span>
                    <span class="ch">'1'</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is balanced&quot;</span>
                    _   <span class="ot">-&gt;</span> return()
    <span class="kw">where</span>
        gateHadamardOnTwoQubits<span class="fu">=</span>(hGate <span class="fu">&lt;+&gt;</span> hGate)
        circuit<span class="fu">=</span>entangle qZero (qZero <span class="fu">|&gt;</span> xGate) <span class="fu">|&gt;</span> gateHadamardOnTwoQubits <span class="fu">|&gt;</span> oracle <span class="fu">|&gt;</span> gateHadamardOnTwoQubits
        measure q<span class="fu">=</span><span class="kw">let</span> result<span class="fu">=</span>map(\c<span class="ot">-&gt;</span>round (realPart (c <span class="fu">*</span> conjugate c))) (toList <span class="fu">.</span> flatten <span class="fu">$</span> qubitState q)        
                  <span class="kw">in</span> <span class="kw">case</span> result <span class="kw">of</span>
                    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]<span class="ot">-&gt;</span><span class="st">&quot;01&quot;</span>
                    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">-&gt;</span><span class="st">&quot;11&quot;</span>
                    _        <span class="ot">-&gt;</span><span class="st">&quot;??&quot;</span></code></pre></div>
<p>If we run the code we will have:</p>
<pre><code>ghci&gt;testDeutschsAlgorithm
Function is constant
Function is constant
Function is balanced
Function is balanced
</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>As we can see in this first example, running an algorithm, even a simple one, on a quantum computer can be faster than running it on a classical computer.</p>
<p>About the implemented library, as I said, you can download it from the links that I specified before and these articles and examples of code will be used as a “How to use..” for the library.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>
