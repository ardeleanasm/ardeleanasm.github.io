<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Posts tagged "haskell"</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="tags/haskell.html">Home</a>
                <a href="../about.html" class="tags/haskell.html">About</a>
                <a href="../archive.html" class="tags/haskell.html">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <ul>
    
        <li>
            <a href="../posts/2017-11-30-Polynomial-Value-in-Haskell.html">Polynomial Value in Haskell</a> - November 30, 2017
            
                <!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Polynomial Value in Haskell</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-11-30-Polynomial-Value-in-Haskell.md">Home</a>
                <a href="../about.html" class="posts/2017-11-30-Polynomial-Value-in-Haskell.md">About</a>
                <a href="../archive.html" class="posts/2017-11-30-Polynomial-Value-in-Haskell.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        Posted on November 30, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <p>While working on a project that analyze some signals in Haskell I found that I need a simple function <code>polyVal</code> that evaluates a polynomial at specific values.</p>
<p>After a failed search for this function ( I thought that I can find a library or an implementation) I decided to write it on my own, anyway, it’s a simple function.</p>
<p>So, let’s suppose we have a polynomial <em>p</em> of degree <em>N</em>, this function returns the value:</p>
<p><span class="math display">\[p_{0}*x^{N-1}+p_{1}*x^{N-2}+...+p_{N-2}*x+p_{N-1}\]</span></p>
<p>The Haskell implementation of this function is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalPoly::</span><span class="dt">Double</span><span class="ot">-&gt;</span>[<span class="dt">Double</span>]<span class="ot">-&gt;</span><span class="dt">Double</span>
evalPoly n xs<span class="fu">=</span>sum <span class="fu">$</span> map (\e<span class="ot">-&gt;</span>e<span class="fu">*</span>n<span class="fu">**</span>fromIntegral ((length xs)<span class="fu">-</span><span class="dv">1</span><span class="fu">-</span>(fromJust <span class="fu">$</span> elemIndex e xs))) xs</code></pre></div>
<p>Example of ussage:</p>
<pre><code>&gt;evalPoly 3 [-19,7,-4,6]
-456.0
&gt;evalPoly 5 [3,0,1]
76.0</code></pre>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>

            
        </li>
    
        <li>
            <a href="../posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a> - August 18, 2017
            
                <!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Quantum Computing in Haskell - IV part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">Home</a>
                <a href="../about.html" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">About</a>
                <a href="../archive.html" class="posts/2017-08-18-Quantum-Computing-in-Haskell-fourth-part.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        Posted on August 18, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the previous articles, first three parts, I presented some haskell code to implement basic operators for simulating Quantum Algorithms. The full source code can be downloaded from <a href="https://github.com/ardeleanasm/qchas">Github Repository</a>. The library was also published on <a href="https://hackage.haskell.org/package/qchas">Hackage</a> and also on <a href="https://www.stackage.org/nightly-2017-08-17/package/qchas-1.0.1.0">Stackage</a> and is available with 2 versions, 1.0.0 and 1.0.1.0. Starting from version 1.0.1.0 the <strong>Utils</strong> module was removed and also, a new module for performing measurements was added. These articles will be also used as documentation/ wiki for the library.</p>
<p>In this fourth part we will start to present some Quantum Algorithms and we will start with one of the simplest ones, Deutsch’s algorithm. In the next articles from the serie we will talk about Deutsch-Jozsa’s algorithm, Grover’s and Shor.</p>
<h2 id="background">Background</h2>
<p>As I said in a previous article when I implemented this algorithm in Java, the problem that Deutsch’s algorithm solves is not an important one in Computer Science but it’s a good example to see the power of quantum computers, being solved by a quantum computer faster than by a traditional one, although not exponentially faster.</p>
<p>So, let’s suppose that we have a function f with 1-bit input and 1-bit output. There are four possible functions, two of them are constant and two are balanced, as we can see in the table below.</p>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="center">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(f_{1}(0)=0, f_{1}(1)=0\)</span></td>
<td align="center">constant</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(f_{2}(0)=1, f_{2}(1)=1\)</span></td>
<td align="center">constant</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(f_{3}(0)=0, f_{3}(1)=1\)</span></td>
<td align="center">balanced</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(f_{4}(0)=1, f_{4}(1)=0\)</span></td>
<td align="center">balanced</td>
</tr>
</tbody>
</table>
<p>The goal is to determine whether the function is constant or not. Let’s say that we implement such a function on a classic computer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main::</span><span class="dt">IO</span> ()
main<span class="fu">=</span><span class="kw">do</span>
  print <span class="fu">$</span> testFunction f1
  print <span class="fu">$</span> testFunction f2
  print <span class="fu">$</span> testFunction f3
  print <span class="fu">$</span> testFunction f4

<span class="ot">f1::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f1 val<span class="fu">=</span><span class="dv">0</span>

<span class="ot">f2::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f2 val<span class="fu">=</span><span class="dv">1</span>

<span class="ot">f3::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f3 val<span class="fu">=</span>val

<span class="ot">f4::</span><span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>
f4 val
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
  <span class="fu">|</span> val<span class="fu">==</span><span class="dv">1</span> <span class="fu">=</span> <span class="dv">0</span>

<span class="ot">testFunction::</span>(<span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span>)<span class="ot">-&gt;</span><span class="dt">String</span>
testFunction f
  <span class="fu">|</span>f <span class="dv">0</span> <span class="fu">==</span> f <span class="dv">1</span><span class="fu">=</span> <span class="st">&quot;Constant&quot;</span>
  <span class="fu">|</span>otherwise<span class="fu">=</span> <span class="st">&quot;Balanced&quot;</span></code></pre></div>
<p>and the output will be:</p>
<pre><code>&quot;Constant&quot;
&quot;Constant&quot;
&quot;Balanced&quot;
&quot;Balanced&quot;</code></pre>
<p>It can be easily seen that to check if a function is constant or balanced on a classical computer we need two calls to that function, basically we evaluate the function twice. We will see next that by using Deutsch’s algorithm the problem can be solved by evaluating the function only once.</p>
<div class="figure">
<img src="../images/deutsch_quantum_circuits.png" alt="The quantum circuit of Deutsch’s algorithm1" />
<p class="caption">The quantum circuit of Deutsch’s algorithm<a href="https://github.com/ardeleanasm/qchas">1</a></p>
</div>
<p>The quantum circuit that we will have to implement can be seen in the picture above and basically we will have to:</p>
<ul>
<li>Apply <strong>X-Gate</strong> on the second qubit</li>
<li>Apply <span class="math inline">\(H^2\)</span> gate, the Kronecker product between two <strong>Hadamard</strong> Gates</li>
<li>Apply the gate ( or “oracle”) <span class="math inline">\(U_f\)</span></li>
<li>Apply Hadamard Gate again on the first qubit</li>
<li>Measure the circuit</li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>First of all, let’s define the unitary transformations for all four functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--f(0)=0 and f(1)=0</span>
<span class="ot">f1::</span><span class="dt">Gate</span>
f1<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=1</span>
<span class="ot">f2::</span><span class="dt">Gate</span>
f2<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=0 and f(1)=1</span>
<span class="ot">f3::</span><span class="dt">Gate</span>
f3<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)
<span class="co">--f(0)=1 and f(1)=0</span>
<span class="ot">f4::</span><span class="dt">Gate</span>
f4<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>
                ,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)                </code></pre></div>
<p>The next step is to define a function that will test all the four functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testDeutschsAlgorithm::</span><span class="dt">IO</span>()
testDeutschsAlgorithm<span class="fu">=</span>mapM_ deutsch [f1,f2,f3,f4]</code></pre></div>
<p>Now, let’s implement the algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">deutsch::</span><span class="dt">Gate</span><span class="ot">-&gt;</span><span class="dt">IO</span>()
deutsch oracle<span class="fu">=</span><span class="kw">do</span> <span class="kw">let</span> (result<span class="fu">:</span>_)<span class="fu">=</span>measure circuit
                  <span class="kw">case</span> result <span class="kw">of</span>
                    <span class="ch">'0'</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is constant&quot;</span>
                    <span class="ch">'1'</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;Function is balanced&quot;</span>
                    _   <span class="ot">-&gt;</span> return()
    <span class="kw">where</span>
        gateHadamardOnTwoQubits<span class="fu">=</span>(hGate <span class="fu">&lt;+&gt;</span> hGate)
        circuit<span class="fu">=</span>entangle qZero (qZero <span class="fu">|&gt;</span> xGate) <span class="fu">|&gt;</span> gateHadamardOnTwoQubits <span class="fu">|&gt;</span> oracle <span class="fu">|&gt;</span> gateHadamardOnTwoQubits
        measure q<span class="fu">=</span><span class="kw">let</span> result<span class="fu">=</span>map(\c<span class="ot">-&gt;</span>round (realPart (c <span class="fu">*</span> conjugate c))) (toList <span class="fu">.</span> flatten <span class="fu">$</span> qubitState q)        
                  <span class="kw">in</span> <span class="kw">case</span> result <span class="kw">of</span>
                    [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>]<span class="ot">-&gt;</span><span class="st">&quot;01&quot;</span>
                    [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">-&gt;</span><span class="st">&quot;11&quot;</span>
                    _        <span class="ot">-&gt;</span><span class="st">&quot;??&quot;</span></code></pre></div>
<p>If we run the code we will have:</p>
<pre><code>ghci&gt;testDeutschsAlgorithm
Function is constant
Function is constant
Function is balanced
Function is balanced
</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>As we can see in this first example, running an algorithm, even a simple one, on a quantum computer can be faster than running it on a classical computer.</p>
<p>About the implemented library, as I said, you can download it from the links that I specified before and these articles and examples of code will be used as a “How to use..” for the library.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>

            
        </li>
    
        <li>
            <a href="../posts/2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a> - August  1, 2017
            
                <!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Quantum Computing in Haskell - III part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-08-01-Quantum-Computing-in-Haskell-third-part.md">Home</a>
                <a href="../about.html" class="posts/2017-08-01-Quantum-Computing-in-Haskell-third-part.md">About</a>
                <a href="../archive.html" class="posts/2017-08-01-Quantum-Computing-in-Haskell-third-part.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        Posted on August  1, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the second part of this series I talked about the Haskell implementation of Qubits. There are two more articles about the library and after that I will start posting about algorithms. In this article we will define some Quantum Gates that we will use in our algorithms, even if in the first article I wrote a little about this topic and I presented some matrices.</p>
<h2 id="background">Background</h2>
<p>As we already know computers are built using logic gates and in a similar way quantum computation also use logic gates that can be designed by considering unitary transformation of the qubits. In conclusion, we can construct infinitely many quantum logic gates with the constraint that they must be reversible.</p>
<p>In the first article from this series I already presented some gates but we didn’t see their symbol or truth table.</p>
<h3 id="qubit-gates">1 qubit gates</h3>
<h4 id="pauli-x-gate-or-not-gate">Pauli X-Gate or NOT gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="../images/xgate.png" title="Pauli XGate" alt="X-Gate Symbol" />
<p class="caption">X-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math display">\[X\ket{0}=\ket{1}, X\ket{1}=\ket{0}\]</span></p>
<h4 id="pauli-y-gate">Pauli Y-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="../images/ygate.png" title="Pauli YGate" alt="Y-Gate Symbol" />
<p class="caption">Y-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Y\ket{0}=i\ket{1}, Y\ket{1}=-i\ket{0}\]</span></p>
<h4 id="pauli-z-gate">Pauli Z-Gate</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="../images/zgate.png" title="Pauli ZGate" alt="Z-Gate Symbol" />
<p class="caption">Z-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}\]</span></p>
<h4 id="hadamard-gate">Hadamard Gate:</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="../images/hgate.png" title="Hadamard Gate" alt="H-Gate Symbol" />
<p class="caption">H-Gate Symbol</p>
</div>
<p><em>Matrix:</em></p>
<p><span class="math display">\[H=\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}\]</span></p>
<p><em>Transformation:</em></p>
<p><span class="math display">\[H\ket{0}=\frac{1}{\sqrt{2}}(\ket{0}+\ket{1}), H\ket{1}=\frac{1}{\sqrt{2}}(\ket{0}-\ket{1})\]</span></p>
<h3 id="controlled-quantum-gates">Controlled Quantum Gates</h3>
<p>Controlled Quantum Gates are useful for implementing <strong>IF-THEN-ELSE</strong> type operations. In this article we will only present <strong>CNOT</strong>.</p>
<h4 id="controlled-not-cnot">Controlled-NOT (CNOT)</h4>
<p><em>Symbol:</em></p>
<div class="figure">
<img src="../images/cnotgate.png" title="Controlled-NOT" alt="CNOT-Gate Symbol" />
<p class="caption">CNOT-Gate Symbol</p>
</div>
<p><em>Truth Table:</em></p>
<table>
<thead>
<tr class="header">
<th align="center">x</th>
<th align="center">y</th>
<th align="center">x <span class="math inline">\((x\oplus y)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0 0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0 1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1 1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1 0</td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>
<p>Having the background now, let’s start implementing those gates in Haskell. First, let’s define a new data named <strong>Gate</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Gate</span><span class="fu">=</span>
  <span class="dt">Gate</span> {
<span class="ot">          gateMatrix::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) 
        } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Our data <strong>Gate</strong> has a constructor <strong>Gate</strong> with one parameter, <strong>gateMatrix</strong>, of type ** complex matrx<strong>, <code>Matrix C</code>. Let’s see the code in </strong>GHCI**:</p>
<p><code>ghci&gt;:t Gate Gate :: Matrix C -&gt; Gate ghci&gt;let g= Gate ((2&gt;&lt;2) [1,0,0,-1]::Matrix C) ghci&gt;g Gate {gateMatrix = (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]} ghci&gt;&gt;gateMatrix g (2&gt;&lt;2)  [ 1.0 :+ 0.0,       0.0 :+ 0.0  , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]</code></p>
<p>In the above example we created a Pauli Z-Gate. We will proceed like for Qubit and we will define some functions that will return a Gate. We will implement the Pauli X-Gate, Y-Gate, Z-Gate, Hadamard Gate, CNOT-Gate, and Controlled Phase Shift Gate ( we will need in Grover’s Algorithm).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xGate::</span><span class="dt">Gate</span>
xGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>)[<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">yGate::</span><span class="dt">Gate</span>
yGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="fl">0.0</span>,<span class="fl">0.0</span><span class="fu">:+</span>(<span class="fu">-</span><span class="fl">1.0</span>),<span class="fl">0.0</span><span class="fu">:+</span><span class="fl">1.0</span>,<span class="fl">0.0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">zGate::</span><span class="dt">Gate</span>
zGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">hGate::</span><span class="dt">Gate</span>
hGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">2</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>,(<span class="fu">-</span><span class="dv">1</span>)<span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cNotGate::</span><span class="dt">Gate</span>
cNotGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">cPhaseShifGate::</span><span class="dt">Gate</span>
cPhaseShifGate<span class="fu">=</span><span class="dt">Gate</span> ((<span class="dv">4</span><span class="fu">&gt;&lt;</span><span class="dv">4</span>)[<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<p>Now, in GHCI, if we call, for example <code>zGate</code> we will see that the output is the same with the one from the previous example:</p>
<pre><code>ghci&gt;zGate
Gate {gateMatrix = (2&gt;&lt;2)
 [ 1.0 :+ 0.0,       0.0 :+ 0.0
 , 0.0 :+ 0.0, (-1.0) :+ (-0.0) ]}
ghci&gt;:t zGate
zGate :: Gate</code></pre>
<h2 id="conclusions">Conclusions</h2>
<p>In this article we implemented some 1-qubit Gates and some Controlled-Gate. In next articles we will define some functions to apply those gate on qubits and also to create gates, starting from 1-qubit ones, that apply on multiple qubits. New ideas, features, issues are welcomed and I encourage every reader to submit them on Github or ask questions using Disquss.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>

            
        </li>
    
        <li>
            <a href="../posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a> - July 28, 2017
            
                <!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Quantum Computing in Haskell - II part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">Home</a>
                <a href="../about.html" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">About</a>
                <a href="../archive.html" class="posts/2017-07-28-Quantum-Computing-in-Haskell-second-part.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        Posted on July 28, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In the first article from this series I presented some basic math and I suggest reading that article first if someone is not familiar with the topic of Quantum Computing. In this article, the second from the series I will present the implementation in Haskell. The plan is that after a few articles in which I will present the data types, modules, functions, we will implement some Quantum algorithms like Deutsch’s Algorithm, Grover’s Algorithm, Deutsch-Josza’s Algorithm and maybe Shor’s algorithm.</p>
<h2 id="background">Background</h2>
<p>We saw in the previous article that the state of a qubit can be described by</p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math display">\[\ket{v}=\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where</p>
<p><span class="math display">\[{|\alpha|}^2+{|\beta|}^2=1\]</span></p>
<p>and</p>
<p><span class="math display">\[\ket{0}=\begin{bmatrix} 1 \\ 0\end{bmatrix}\]</span> <span class="math display">\[\ket{1}=\begin{bmatrix} 0 \\ 1\end{bmatrix}\]</span></p>
<p>It’s clearly, from the above equations, that we have to implement a Qubit type and the qubits <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>.</p>
<h2 id="implementation">Implementation</h2>
<p>For the implementation in Haskell I chose to use <a href="https://hackage.haskell.org/package/hmatrix">hmatrix</a> library because we will have to work with matrices and vectors and by using this library we won’t have to implement new types and functions that performs the needed operations.</p>
<p>Anyway, a simple solution that don’t use hmatrix is to define our own <strong>matrix</strong> and <strong>vector</strong> types like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Vector</span> a<span class="fu">=</span>[a]
<span class="kw">type</span> <span class="dt">Matrix</span> a<span class="fu">=</span>[<span class="dt">Vector</span> a]</code></pre></div>
<p>and also some functions that will create our complex vectors and matrices</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">complexVector::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Vector</span> a<span class="ot">-&gt;</span><span class="dt">Vector</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)
complexVector<span class="fu">=</span>map(\i<span class="ot">-&gt;</span>realToFrac i<span class="fu">:+</span><span class="fl">0.0</span>)

<span class="ot">complexMatrix::</span><span class="dt">Real</span> a<span class="ot">=&gt;</span><span class="dt">Matrix</span> a<span class="ot">-&gt;</span><span class="dt">Matrix</span>(<span class="dt">Complex</span> <span class="dt">Double</span>)
complexMatrix<span class="fu">=</span>map complexVector</code></pre></div>
<p>Since I don’t think that is a feasible approach I won’t discuss the above code. Is nice to know that we can implement it without using hmatrix, is another approach, even the first version of code from repository was implemented this way but it’s a lot of work. I won’t reinvent the wheel, at least for now! :)</p>
<p>Ok, first of all let’s define a new data named <strong>Qubit</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Qubit</span><span class="fu">=</span>
    <span class="dt">Qubit</span> {
<span class="ot">            qubitState::</span>(<span class="dt">Matrix</span> <span class="dt">C</span>) 
          } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</code></pre></div>
<p>Our data type has a constructor <strong>Qubit</strong> with one parameter, <strong>qubitState</strong>, of type <strong>complex matrix</strong>, <code>Matrix C</code>. If we load the above code in <strong>GHCI</strong> we can check the new type that we defined:</p>
<pre><code>ghci&gt; :t Qubit
Qubit :: Matrix C -&gt; Qubit
</code></pre>
<p>We can see that Qubit is the data type and the constructors accepts an argument of type <em>Matrix C</em> and returns a <em>Qubit</em>. Ok, now let’s try to create a Qubit.</p>
<pre><code>ghci&gt;let q=Qubit ((2&gt;&lt;1)[1,0]::Matrix C)
ghci&gt;q
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;qubitState q
(2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]</code></pre>
<p>Basically, in the above example we created the <span class="math inline">\(\ket{0}\)</span>. Since in our future examples we will use it a lot alongside <span class="math inline">\(\ket{1}\)</span> we should define some functions that will return them.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qZero::</span><span class="dt">Qubit</span>
qZero<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>)[<span class="dv">1</span>,<span class="dv">0</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">qOne::</span><span class="dt">Qubit</span>
qOne<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">0</span>,<span class="dv">1</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<p>One question that might arise after seeing the code is “Ok, why is Matrix type used instead of Vector?” The answer is quite simple, because we will have to implement, in the next articles, some operations with qubits and gates and is more simple to have the same type for both. Now, if we fire up GHCI and type:</p>
<pre><code>ghci&gt;&gt;qZero
Qubit {qubitState = (2&gt;&lt;1)
 [ 1.0 :+ 0.0
 , 0.0 :+ 0.0 ]}
ghci&gt;&gt;qOne
Qubit {qubitState = (2&gt;&lt;1)
 [ 0.0 :+ 0.0
 , 1.0 :+ 0.0 ]}</code></pre>
<p>we see that we have two functions that returns our needed qubits.</p>
<p>After the experience that I have with <a href="https://github.com/ardeleanasm/quantum_computing">Java Library for Quantum Computing</a> I think that is useful to also define two more qubits, <span class="math inline">\(\ket{+}\)</span> and <span class="math inline">\(\ket{-}\)</span>. Those qubits can be simply obtained by simply applying the Hadamard Gate on <span class="math inline">\(\ket{0}\)</span> and on <span class="math inline">\(\ket{1}\)</span> respectively.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qPlus::</span><span class="dt">Qubit</span>
qPlus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>, <span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)

<span class="ot">qMinus::</span><span class="dt">Qubit</span> 
qMinus<span class="fu">=</span><span class="dt">Qubit</span> ((<span class="dv">2</span><span class="fu">&gt;&lt;</span><span class="dv">1</span>) [<span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>, <span class="fu">-</span><span class="dv">1</span><span class="fu">/</span>sqrt <span class="dv">2</span>]<span class="ot">::</span><span class="dt">Matrix</span> <span class="dt">C</span>)</code></pre></div>
<h2 id="conclusions">Conclusions</h2>
<p>For now, we have defined a Qubit type and we can create any qubit. We also define some functions that will create the most used qubits. In future articles we will define a Gate type and we will also implement some operations.</p>
<p>Based on my experience that I have on this topic after doing some research and implementing from scratch a library in Java I was surprised when I saw how fast I can implement this code in Haskell. It was quite simple and it took less time.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>

            
        </li>
    
        <li>
            <a href="../posts/2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a> - July 26, 2017
            
                <!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="../assets/favicon.png">
        <link rel="apple-touch-icon" href="../assets/touch-icon.png">
        <title>Laziness leads to progress - Quantum Computing in Haskell - I part</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
      <div class="highbar">&nbsp;</div>
        <div id="header">
          <div class="box">
            <div id="logo" class="name">
              <h2><a href="../">Laziness leads to progress!</a></h2>
            </div>
            <div id="navigation" class="pageslinks">
              <nav class="menuNav">
                <div class="menuItems">
                <a href="../" class="posts/2017-07-26-Quantum-Computing-in-Haskell.md">Home</a>
                <a href="../about.html" class="posts/2017-07-26-Quantum-Computing-in-Haskell.md">About</a>
                <a href="../archive.html" class="posts/2017-07-26-Quantum-Computing-in-Haskell.md">Archive</a>
                </div>
              </nav>
            </div>
        </div>
        </div>
        <div class="container-gallery">
        <div id="content" class="inside">
            <article>
    <section class="header">
        Posted on July 26, 2017
        
    </section>
    <div class="info">
        
        Tags: <a href="../tags/haskell.html">haskell</a>
        
    </div>
    <section>
        <h2 id="articles">Articles</h2>
<ul>
<li><a href="2017-07-26-Quantum-Computing-in-Haskell.html">Quantum Computing in Haskell - I part</a></li>
<li><a href="2017-07-28-Quantum-Computing-in-Haskell-second-part.html">Quantum Computing in Haskell - II part</a></li>
<li><a href="2017-08-01-Quantum-Computing-in-Haskell-third-part.html">Quantum Computing in Haskell - III part</a></li>
<li><a href="2017-08-18-Quantum-Computing-in-Haskell-fourth-part.html">Quantum Computing in Haskell - IV part</a></li>
<li><a href="https://github.com/ardeleanasm/qchas">Github Repository</a></li>
<li><a href="https://ardeleanasm.github.io/qchas/">Project’s Haddock Documentation</a></li>
<li><a href="https://hackage.haskell.org/package/qchas">QChas Package</a></li>
</ul>
<h2 id="long-story-made-short">Long story made short</h2>
<p>1 year ago I started studying the topics of Quantum Computing and Quantum Algorithms and I was fascinated. Is interresting and, like Niels Bohr said, “Anyone who is not shocked by quantum theory has not understood it.”</p>
<p>As doing my research I found quite interesting to post some small articles on these topics, some articles on CodeProject (<a href="https://www.codeproject.com/Articles/1130092/Java-based-Quantum-Computing-library">Java based Quantum Computing Library</a> and <a href="https://www.codeproject.com/Articles/1131573/Grovers-Search-Algorithm-explained">Grover’s Search Algorithm Explained</a>) and one on my website about <a href="2016-08-17-deutschs-algorithm.html">Deutsch’s algorithm</a>. For those articles I used a Java library that I created myself with the help of some of my colleagues. Now, after a year and after playing a little with Haskell, I found quite interesting to review the topic and to start posting a series of small articles about Quantum Computing.</p>
<h2 id="introduction">Introduction</h2>
<p>I’ll start by talking a little about the difference between a quantum computer and a traditional one. A lot of information about how a quantum computer works can be found in online courses, research papers and books. It’s not the scope of this post to explain in details how it works, just to present some basic differences.</p>
<p>As someone can expect, a quantum computer use the quantum mechanical effects, such as superposition, to carry out computations. We already know that in a traditional computer, the <strong>bit</strong> is the basic unit and it can be 0 or 1. The value is defined by a voltage level, in TTL technology, ideally, a 1 value is represented by 5.00 volts while a 0 value is represented by 0.00 volts. For a quantum computer, there are some differences. For example, the basic unit is the <strong>qubit</strong> (quantum bit) and can, at one time, represent value 0 and 1, by exploiting superposition. A qubit is defined by the equation presented below:</p>
<p><span class="math inline">\(\newcommand{\ket}[1]{\left|{#1}\right\rangle}\)</span> <span class="math inline">\(\newcommand{\bra}[1]{\left\langle{#1}\right|}\)</span> <span class="math inline">\(\ket{v}=\alpha\ket{0}+\beta\ket{1}\)</span></p>
<p>Before diving deeper into the subject, we will firstly review some mathematical aspects of the topic.</p>
<h2 id="complex-numbers">Complex Numbers</h2>
<p>Since probability amplitudes of a qubit are complex numbers I prefer to start with a very short introduction in the mathematics of complex numbers.</p>
<p>A complex number q is defined as <span class="math inline">\(q=a+bi\)</span> where a and b <span class="math inline">\(\in \mathcal{R}\)</span> and <span class="math inline">\(i=\sqrt{-1}\)</span> is the imaginary basis unit.</p>
<p>We can see that <strong>a</strong> is the real component of a complex number and <strong>bi</strong> is the imaginary one. We can obtain the complex conjugate by simply negating the sign of the imaginary component <span class="math inline">\(\overline{q}=a-bi\)</span>.</p>
<p>Some basic formulas that we will use during this series of articles will be addition, multiplication, and modulus.</p>
<p>Let’s consider 2 complex numbers x and y defined like:</p>
<p><span class="math display">\[x=a+bi\]</span></p>
<p>and</p>
<p><span class="math display">\[y=c+di\]</span></p>
<p>The addition of these 2 complex numbers is defined by:</p>
<p><span class="math display">\[z=x+y=a+bi+c+di=a+c+i(b+d)\]</span></p>
<p>while multiplication is defined by:</p>
<p><span class="math display">\[z=x*y=(a+bi)(c+di)=ac-bd+i(ad+cb)\]</span></p>
<p>The third operation, the modulus of the complex number x is defined by:</p>
<p><span class="math display">\[|x|=\sqrt{a^2+b^2}\]</span></p>
<h2 id="vectors">Vectors</h2>
<p>While Complex Numbers are used to represent the probability amplitudes of a qubit, vectors and linear algebra helps us to represent qubits, so I decided that it’ll be usefull to present some notations and operations before starting to write code.</p>
<p>Basically, the state of a qubit is a unit vector in a 2-dimensional complex vector space <span class="math inline">\(\mathcal{C}^2\)</span>.</p>
<p>The vector <span class="math display">\[\begin{bmatrix}\alpha\\ \beta\end{bmatrix}\]</span> can be written as</p>
<p><span class="math display">\[\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where</p>
<p><span class="math display">\[\ket{0}=\begin{bmatrix}1\\0\end{bmatrix}\]</span></p>
<p>and</p>
<p><span class="math display">\[\ket{1}=\begin{bmatrix}0\\1\end{bmatrix}\]</span></p>
<p>In the above example I used the <strong>bra-ket</strong> notation, the notation of a column vector is called <strong>ket</strong> while the notation of a row vector is called <strong>bra</strong>. Next, I will define 3 basic operations that will be used heavily in the examples from the next articles on this topic, the inner product, outer product and tensor product.</p>
<p>The inner product, <span class="math inline">\(\bra{v}\ket{v}\)</span> is the product between the bra and the ket vectors:</p>
<p><span class="math display">\[\bra{v}\ket{v}=\begin{pmatrix}{c_1}^* &amp; {c_2}^* \end{pmatrix}\begin{pmatrix}{c_1} \\ {c_2} \end{pmatrix}={c_1}^*{c_1}+{c_2}^*{c_2}={|c_1|}^2+{|c_2|}^2\]</span></p>
<p>Outer product is <strong>ket-bra</strong> and is given by:</p>
<p><span class="math display">\[\ket{v}\bra{v}=\begin{pmatrix}c_1 \\ c_2 \end{pmatrix}\begin{pmatrix}{c_1}^* &amp; {c_2}^*\end{pmatrix}=\begin{pmatrix} c_1{c_1}^* &amp; c_1{c_2}^* \\ c_2{c_1}^* &amp; c_2{c_2}^* \end{pmatrix}\]</span></p>
<p>Lastly, if we consider <span class="math display">\[\ket{v}=\begin{pmatrix}{c_1} \\ {c_2} \end{pmatrix}\]</span> and <span class="math display">\[\ket{x}=\begin{pmatrix}{c_3} \\ {c_4} \end{pmatrix}\]</span> we can define the tensor product as:</p>
<p><span class="math display">\[\ket{v}\otimes\ket{x}=\ket{vx}=\begin{pmatrix}{c_1}{c_3} \\ {c_2}{c_3} \\ {c_1}{c_4} \\ {c_2}{c_4} \end{pmatrix}\]</span></p>
<h2 id="qubits-and-gates">Qubits and Gates</h2>
<p>Quantum mechanics tells that any such system can exist in a superposition of states and as we saw in the second chapter, the state of a qubit is described by</p>
<p><span class="math display">\[\ket{v}=\alpha\ket{0}+\beta\ket{1}\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are complex number that satisfy the relation</p>
<p><span class="math display">\[{|\alpha|}^2+{|\beta|}^2=1\]</span></p>
<p>We know that on a classic computer gate operations such as <strong>AND</strong>, <strong>OR</strong>,<strong>XOR</strong> constitute the core of data manipulation. On a quantum computer similar operations are possible on qubits by using quantum gates. The gate operations are exactly all unitary linear operations.</p>
<p>For example, the Hadamard transformation is defined as:</p>
<p><span class="math display">\[\alpha\ket{0}+\beta\ket{1}\rightarrow\frac{\alpha+\beta}{\sqrt{2}}\ket{0}+\frac{\alpha-\beta}{\sqrt{2}}\ket{1}\]</span></p>
<p>Knowing that <span class="math display">\[\ket{0}=\begin{bmatrix}{1} \\ {0} \end{bmatrix}\]</span> and <span class="math display">\[\ket{1}=\begin{bmatrix}{0} \\ {1} \end{bmatrix}\]</span> then we can represent the transformation as the matrix:</p>
<p><span class="math display">\[\frac{1}{\sqrt{2}}\begin{pmatrix}1 &amp; 1 \\ 1 &amp; -1 \end{pmatrix}\]</span></p>
<p>A Hadamard gate creates a superposition state, often beginning and ending a quantum computation to initiate data processing and to collect data, respectively.</p>
<p>A set of useful 1-qubit gates are the Pauli Gates, the X gate, Y gate and Z gate.</p>
<p><span class="math display">\[X\ket{0}=\ket{1} and X\ket{1}=\ket{1}; X=\begin{pmatrix}0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p>
<p><span class="math display">\[Y\ket{0}=i\ket{1} and Y\ket{1}=-i\ket{0}; Y=\begin{pmatrix}0 &amp; -i \\ i &amp; 0 \end{pmatrix}\]</span></p>
<p><span class="math display">\[Z\ket{0}=\ket{0} and Z\ket{1}=-\ket{1}; Z=\begin{pmatrix}1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}\]</span></p>
<p>Two more gates that we will use in our examples are the Controlled-Not and Controlled Phase Shift and they are defined by the following matrices:</p>
<p><span class="math display">\[Controlled Phase Shift=\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1\end{pmatrix}\]</span></p>
<p><span class="math display">\[Controlled Not=\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{pmatrix}\]</span></p>
<p>In the next article we will write some code that implements some basic operations.</p>
        <div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = '23ars';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

    </section>
</article>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>

            
        </li>
    
</ul>

        </div>
        </div>
        <div id="footer">
          <div class="inside">
            Site proudly generated by
	     <link rel="stylesheet" href="../css/core.css" />





<a href="https://github.com/ardeleanasm"><i class="svg-icon github"></i></a>
<a href="https://www.linkedin.com/in/ardelean-sebastian-mihai"><i class="svg-icon linkedin"></i></a>
<a href="https://ardeleanasm.github.io/atom.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/mihaiseba"><i class="svg-icon twitter"></i></a>
<a href="http://stackoverflow.com/users/1462225/23ars"><i class="svg-icon stackoverflow"></i></a>
<a href="https://www.haskellers.com/user/4914"><img src="https://www.haskellers.com/static/badge.png" alt="I'm a Haskeller">
</a>
</br>
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.

          </div>
        </div>
    </body>
</html>
